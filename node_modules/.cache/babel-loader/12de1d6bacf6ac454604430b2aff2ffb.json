{"ast":null,"code":"var _regeneratorRuntime = require(\"F:\\\\Mattia\\\\Visual studio\\\\AppCroskull\\\\croskull-nft-marketplace\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"F:\\\\Mattia\\\\Visual studio\\\\AppCroskull\\\\croskull-nft-marketplace\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"F:\\\\Mattia\\\\Visual studio\\\\AppCroskull\\\\croskull-nft-marketplace\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"F:\\\\Mattia\\\\Visual studio\\\\AppCroskull\\\\croskull-nft-marketplace\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"F:\\\\Mattia\\\\Visual studio\\\\AppCroskull\\\\croskull-nft-marketplace\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"F:\\\\Mattia\\\\Visual studio\\\\AppCroskull\\\\croskull-nft-marketplace\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"F:\\\\Mattia\\\\Visual studio\\\\AppCroskull\\\\croskull-nft-marketplace\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar pify = require('pify');\n\nvar BaseBlockTracker = require('./base');\n\nvar sec = 1000;\n\nvar PollingBlockTracker = /*#__PURE__*/function (_BaseBlockTracker) {\n  \"use strict\";\n\n  _inherits(PollingBlockTracker, _BaseBlockTracker);\n\n  function PollingBlockTracker() {\n    var _this;\n\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, PollingBlockTracker);\n\n    // parse + validate args\n    if (!opts.provider) throw new Error('PollingBlockTracker - no provider specified.');\n    var pollingInterval = opts.pollingInterval || 20 * sec;\n    var retryTimeout = opts.retryTimeout || pollingInterval / 10;\n    var keepEventLoopActive = opts.keepEventLoopActive !== undefined ? opts.keepEventLoopActive : true;\n    var setSkipCacheFlag = opts.setSkipCacheFlag || false; // BaseBlockTracker constructor\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(PollingBlockTracker).call(this, Object.assign({\n      blockResetDuration: pollingInterval\n    }, opts))); // config\n\n    _this._provider = opts.provider;\n    _this._pollingInterval = pollingInterval;\n    _this._retryTimeout = retryTimeout;\n    _this._keepEventLoopActive = keepEventLoopActive;\n    _this._setSkipCacheFlag = setSkipCacheFlag;\n    return _this;\n  } //\n  // public\n  //\n  // trigger block polling\n\n\n  _createClass(PollingBlockTracker, [{\n    key: \"checkForLatestBlock\",\n    value: function () {\n      var _checkForLatestBlock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this._updateLatestBlock();\n\n              case 2:\n                _context.next = 4;\n                return this.getLatestBlock();\n\n              case 4:\n                return _context.abrupt(\"return\", _context.sent);\n\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function checkForLatestBlock() {\n        return _checkForLatestBlock.apply(this, arguments);\n      }\n\n      return checkForLatestBlock;\n    }() //\n    // private\n    //\n\n  }, {\n    key: \"_start\",\n    value: function _start() {\n      var _this2 = this;\n\n      this._performSync().catch(function (err) {\n        return _this2.emit('error', err);\n      });\n    }\n  }, {\n    key: \"_performSync\",\n    value: function () {\n      var _performSync2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var newErr;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!this._isRunning) {\n                  _context2.next = 16;\n                  break;\n                }\n\n                _context2.prev = 1;\n                _context2.next = 4;\n                return this._updateLatestBlock();\n\n              case 4:\n                _context2.next = 6;\n                return timeout(this._pollingInterval, !this._keepEventLoopActive);\n\n              case 6:\n                _context2.next = 14;\n                break;\n\n              case 8:\n                _context2.prev = 8;\n                _context2.t0 = _context2[\"catch\"](1);\n                newErr = new Error(\"PollingBlockTracker - encountered an error while attempting to update latest block:\\n\".concat(_context2.t0.stack));\n\n                try {\n                  this.emit('error', newErr);\n                } catch (emitErr) {\n                  console.error(newErr);\n                }\n\n                _context2.next = 14;\n                return timeout(this._retryTimeout, !this._keepEventLoopActive);\n\n              case 14:\n                _context2.next = 0;\n                break;\n\n              case 16:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[1, 8]]);\n      }));\n\n      function _performSync() {\n        return _performSync2.apply(this, arguments);\n      }\n\n      return _performSync;\n    }()\n  }, {\n    key: \"_updateLatestBlock\",\n    value: function () {\n      var _updateLatestBlock2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var latestBlock;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this._fetchLatestBlock();\n\n              case 2:\n                latestBlock = _context3.sent;\n\n                this._newPotentialLatest(latestBlock);\n\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function _updateLatestBlock() {\n        return _updateLatestBlock2.apply(this, arguments);\n      }\n\n      return _updateLatestBlock;\n    }()\n  }, {\n    key: \"_fetchLatestBlock\",\n    value: function () {\n      var _fetchLatestBlock2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var _this3 = this;\n\n        var req, res;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                req = {\n                  jsonrpc: \"2.0\",\n                  id: 1,\n                  method: 'eth_blockNumber',\n                  params: []\n                };\n                if (this._setSkipCacheFlag) req.skipCache = true;\n                _context4.next = 4;\n                return pify(function (cb) {\n                  return _this3._provider.sendAsync(req, cb);\n                })();\n\n              case 4:\n                res = _context4.sent;\n\n                if (!res.error) {\n                  _context4.next = 7;\n                  break;\n                }\n\n                throw new Error(\"PollingBlockTracker - encountered error fetching block:\\n\".concat(res.error));\n\n              case 7:\n                return _context4.abrupt(\"return\", res.result);\n\n              case 8:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function _fetchLatestBlock() {\n        return _fetchLatestBlock2.apply(this, arguments);\n      }\n\n      return _fetchLatestBlock;\n    }()\n  }]);\n\n  return PollingBlockTracker;\n}(BaseBlockTracker);\n\nmodule.exports = PollingBlockTracker;\n\nfunction timeout(duration, unref) {\n  return new Promise(function (resolve) {\n    var timoutRef = setTimeout(resolve, duration); // don't keep process open\n\n    if (timoutRef.unref && unref) {\n      timoutRef.unref();\n    }\n  });\n}","map":null,"metadata":{},"sourceType":"script"}