{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"F:\\\\Mattia\\\\Visual studio\\\\ProjectCroSkull\\\\croskull-nft-marketplace\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"F:\\\\Mattia\\\\Visual studio\\\\ProjectCroSkull\\\\croskull-nft-marketplace\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"F:\\\\Mattia\\\\Visual studio\\\\ProjectCroSkull\\\\croskull-nft-marketplace\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Hmac = void 0;\n\nvar Hmac = /*#__PURE__*/function () {\n  function Hmac(hashFunctionConstructor, originalKey) {\n    _classCallCheck(this, Hmac);\n\n    // This implementation is based on https://en.wikipedia.org/wiki/HMAC#Implementation\n    // with the addition of incremental hashing support. Thus part of the algorithm\n    // is in the constructor and the rest in digest().\n    var blockSize = new hashFunctionConstructor().blockSize;\n\n    this.hash = function (data) {\n      return new hashFunctionConstructor().update(data).digest();\n    };\n\n    var key = originalKey;\n\n    if (key.length > blockSize) {\n      key = this.hash(key);\n    }\n\n    if (key.length < blockSize) {\n      var zeroPadding = new Uint8Array(blockSize - key.length);\n      key = new Uint8Array([].concat(_toConsumableArray(key), _toConsumableArray(zeroPadding)));\n    } // eslint-disable-next-line no-bitwise\n\n\n    this.oKeyPad = key.map(function (keyByte) {\n      return keyByte ^ 0x5c;\n    }); // eslint-disable-next-line no-bitwise\n\n    this.iKeyPad = key.map(function (keyByte) {\n      return keyByte ^ 0x36;\n    });\n    this.messageHasher = new hashFunctionConstructor();\n    this.blockSize = blockSize;\n    this.update(this.iKeyPad);\n  }\n\n  _createClass(Hmac, [{\n    key: \"update\",\n    value: function update(data) {\n      this.messageHasher.update(data);\n      return this;\n    }\n  }, {\n    key: \"digest\",\n    value: function digest() {\n      var innerHash = this.messageHasher.digest();\n      return this.hash(new Uint8Array([].concat(_toConsumableArray(this.oKeyPad), _toConsumableArray(innerHash))));\n    }\n  }]);\n\n  return Hmac;\n}();\n\nexports.Hmac = Hmac;","map":null,"metadata":{},"sourceType":"script"}