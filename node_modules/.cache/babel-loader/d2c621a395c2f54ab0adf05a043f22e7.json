{"ast":null,"code":"var _regeneratorRuntime = require(\"F:\\\\Mattia\\\\Visual studio\\\\AppCroskull\\\\croskull-nft-marketplace\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"F:\\\\Mattia\\\\Visual studio\\\\AppCroskull\\\\croskull-nft-marketplace\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"F:\\\\Mattia\\\\Visual studio\\\\AppCroskull\\\\croskull-nft-marketplace\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"F:\\\\Mattia\\\\Visual studio\\\\AppCroskull\\\\croskull-nft-marketplace\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"F:\\\\Mattia\\\\Visual studio\\\\AppCroskull\\\\croskull-nft-marketplace\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _get = require(\"F:\\\\Mattia\\\\Visual studio\\\\AppCroskull\\\\croskull-nft-marketplace\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"F:\\\\Mattia\\\\Visual studio\\\\AppCroskull\\\\croskull-nft-marketplace\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"F:\\\\Mattia\\\\Visual studio\\\\AppCroskull\\\\croskull-nft-marketplace\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"F:\\\\Mattia\\\\Visual studio\\\\AppCroskull\\\\croskull-nft-marketplace\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/assertThisInitialized\");\n\nvar EthQuery = require('eth-query');\n\nvar pify = require('pify');\n\nvar SafeEventEmitter = require('safe-event-emitter');\n\nvar sec = 1000;\n\nvar calculateSum = function calculateSum(accumulator, currentValue) {\n  return accumulator + currentValue;\n};\n\nvar blockTrackerEvents = ['sync', 'latest'];\n\nvar BaseBlockTracker = /*#__PURE__*/function (_SafeEventEmitter) {\n  \"use strict\";\n\n  _inherits(BaseBlockTracker, _SafeEventEmitter);\n\n  //\n  // public\n  //\n  function BaseBlockTracker() {\n    var _this;\n\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, BaseBlockTracker);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(BaseBlockTracker).call(this)); // config\n\n    _this._blockResetDuration = opts.blockResetDuration || 20 * sec; // state\n\n    _this._blockResetTimeout;\n    _this._currentBlock = null;\n    _this._isRunning = false; // bind functions for internal use\n\n    _this._onNewListener = _this._onNewListener.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this._onRemoveListener = _this._onRemoveListener.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this._resetCurrentBlock = _this._resetCurrentBlock.bind(_assertThisInitialized(_assertThisInitialized(_this))); // listen for handler changes\n\n    _this._setupInternalEvents();\n\n    return _this;\n  }\n\n  _createClass(BaseBlockTracker, [{\n    key: \"isRunning\",\n    value: function isRunning() {\n      return this._isRunning;\n    }\n  }, {\n    key: \"getCurrentBlock\",\n    value: function getCurrentBlock() {\n      return this._currentBlock;\n    }\n  }, {\n    key: \"getLatestBlock\",\n    value: function () {\n      var _getLatestBlock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _this2 = this;\n\n        var latestBlock;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this._currentBlock) {\n                  _context.next = 2;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", this._currentBlock);\n\n              case 2:\n                _context.next = 4;\n                return new Promise(function (resolve) {\n                  return _this2.once('latest', resolve);\n                });\n\n              case 4:\n                latestBlock = _context.sent;\n                return _context.abrupt(\"return\", latestBlock);\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getLatestBlock() {\n        return _getLatestBlock.apply(this, arguments);\n      }\n\n      return getLatestBlock;\n    }() // dont allow module consumer to remove our internal event listeners\n\n  }, {\n    key: \"removeAllListeners\",\n    value: function removeAllListeners(eventName) {\n      // perform default behavior, preserve fn arity\n      if (eventName) {\n        _get(_getPrototypeOf(BaseBlockTracker.prototype), \"removeAllListeners\", this).call(this, eventName);\n      } else {\n        _get(_getPrototypeOf(BaseBlockTracker.prototype), \"removeAllListeners\", this).call(this);\n      } // re-add internal events\n\n\n      this._setupInternalEvents(); // trigger stop check just in case\n\n\n      this._onRemoveListener();\n    } //\n    // to be implemented in subclass\n    //\n\n  }, {\n    key: \"_start\",\n    value: function _start() {// default behavior is noop\n    }\n  }, {\n    key: \"_end\",\n    value: function _end() {// default behavior is noop\n    } //\n    // private\n    //\n\n  }, {\n    key: \"_setupInternalEvents\",\n    value: function _setupInternalEvents() {\n      // first remove listeners for idempotence\n      this.removeListener('newListener', this._onNewListener);\n      this.removeListener('removeListener', this._onRemoveListener); // then add them\n\n      this.on('newListener', this._onNewListener);\n      this.on('removeListener', this._onRemoveListener);\n    }\n  }, {\n    key: \"_onNewListener\",\n    value: function _onNewListener(eventName, handler) {\n      // `newListener` is called *before* the listener is added\n      if (!blockTrackerEvents.includes(eventName)) return;\n\n      this._maybeStart();\n    }\n  }, {\n    key: \"_onRemoveListener\",\n    value: function _onRemoveListener(eventName, handler) {\n      // `removeListener` is called *after* the listener is removed\n      if (this._getBlockTrackerEventCount() > 0) return;\n\n      this._maybeEnd();\n    }\n  }, {\n    key: \"_maybeStart\",\n    value: function _maybeStart() {\n      if (this._isRunning) return;\n      this._isRunning = true; // cancel setting latest block to stale\n\n      this._cancelBlockResetTimeout();\n\n      this._start();\n    }\n  }, {\n    key: \"_maybeEnd\",\n    value: function _maybeEnd() {\n      if (!this._isRunning) return;\n      this._isRunning = false;\n\n      this._setupBlockResetTimeout();\n\n      this._end();\n    }\n  }, {\n    key: \"_getBlockTrackerEventCount\",\n    value: function _getBlockTrackerEventCount() {\n      var _this3 = this;\n\n      return blockTrackerEvents.map(function (eventName) {\n        return _this3.listenerCount(eventName);\n      }).reduce(calculateSum);\n    }\n  }, {\n    key: \"_newPotentialLatest\",\n    value: function _newPotentialLatest(newBlock) {\n      var currentBlock = this._currentBlock; // only update if blok number is higher\n\n      if (currentBlock && hexToInt(newBlock) <= hexToInt(currentBlock)) return;\n\n      this._setCurrentBlock(newBlock);\n    }\n  }, {\n    key: \"_setCurrentBlock\",\n    value: function _setCurrentBlock(newBlock) {\n      var oldBlock = this._currentBlock;\n      this._currentBlock = newBlock;\n      this.emit('latest', newBlock);\n      this.emit('sync', {\n        oldBlock: oldBlock,\n        newBlock: newBlock\n      });\n    }\n  }, {\n    key: \"_setupBlockResetTimeout\",\n    value: function _setupBlockResetTimeout() {\n      // clear any existing timeout\n      this._cancelBlockResetTimeout(); // clear latest block when stale\n\n\n      this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this._blockResetDuration); // nodejs - dont hold process open\n\n      if (this._blockResetTimeout.unref) {\n        this._blockResetTimeout.unref();\n      }\n    }\n  }, {\n    key: \"_cancelBlockResetTimeout\",\n    value: function _cancelBlockResetTimeout() {\n      clearTimeout(this._blockResetTimeout);\n    }\n  }, {\n    key: \"_resetCurrentBlock\",\n    value: function _resetCurrentBlock() {\n      this._currentBlock = null;\n    }\n  }]);\n\n  return BaseBlockTracker;\n}(SafeEventEmitter);\n\nmodule.exports = BaseBlockTracker;\n\nfunction hexToInt(hexInt) {\n  return Number.parseInt(hexInt, 16);\n}","map":null,"metadata":{},"sourceType":"script"}