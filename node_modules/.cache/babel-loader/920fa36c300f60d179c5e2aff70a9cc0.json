{"ast":null,"code":"import _regeneratorRuntime from \"F:\\\\Mattia\\\\Visual studio\\\\ProjectCroSkull\\\\croskull-nft-marketplace\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _asyncToGenerator from \"F:\\\\Mattia\\\\Visual studio\\\\ProjectCroSkull\\\\croskull-nft-marketplace\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport { ethers } from \"ethers\";\nimport store from \"../store\";\nimport { sendNotification, getSkullsData } from \"../data/dataActions\";\n\nvar fetchRaffleRequest = function fetchRaffleRequest() {\n  return {\n    type: \"FETCH_RAFFLE_REQUEST\"\n  };\n};\n\nvar fetchRaffleSuccess = function fetchRaffleSuccess(payload) {\n  return {\n    type: \"FETCH_RAFFLE_SUCCESS\",\n    payload: payload\n  };\n};\n\nexport var loadRaffleData = function loadRaffleData() {\n  return /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(dispatch) {\n      var _store$getState$block, accountAddress, croRaffle, croSkullsGrave, raffleCount, raffles, i, raffle, winners, isParticipant, playersCount, ipfsHash, hashMetadata, _hashMetadata, type, title, winnersCount, maxParticipants, cost, collectionName, collectionAddress, startTimestamp, description, image, isManager, owner, allowance;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              dispatch(fetchRaffleRequest());\n              _store$getState$block = store.getState().blockchain, accountAddress = _store$getState$block.accountAddress, croRaffle = _store$getState$block.croRaffle, croSkullsGrave = _store$getState$block.croSkullsGrave;\n              _context.next = 4;\n              return croRaffle.raffleCounter();\n\n            case 4:\n              raffleCount = _context.sent;\n              raffles = [];\n              _context.next = 8;\n              return raffleCount.toString();\n\n            case 8:\n              raffleCount = _context.sent;\n\n              if (!raffleCount) {\n                _context.next = 38;\n                break;\n              }\n\n              i = raffleCount - 1;\n\n            case 11:\n              if (!(i > 1)) {\n                _context.next = 38;\n                break;\n              }\n\n              if (!(i <= 1)) {\n                _context.next = 14;\n                break;\n              }\n\n              return _context.abrupt(\"return\");\n\n            case 14:\n              _context.next = 16;\n              return croRaffle.getRaffle(i);\n\n            case 16:\n              raffle = _context.sent;\n              _context.next = 19;\n              return croRaffle.getWinners(i);\n\n            case 19:\n              winners = _context.sent;\n              _context.next = 22;\n              return croRaffle.isParticipant(i);\n\n            case 22:\n              isParticipant = _context.sent;\n              _context.next = 25;\n              return raffle.playersCount.toString();\n\n            case 25:\n              playersCount = _context.sent;\n              ipfsHash = raffle.ipfsHash.replace('ipfs://', 'https://ipfs.infura.io/ipfs/');\n              _context.next = 29;\n              return fetch(ipfsHash);\n\n            case 29:\n              hashMetadata = _context.sent;\n              _context.next = 32;\n              return hashMetadata.json();\n\n            case 32:\n              hashMetadata = _context.sent;\n              _hashMetadata = hashMetadata, type = _hashMetadata.type, title = _hashMetadata.title, winnersCount = _hashMetadata.winnersCount, maxParticipants = _hashMetadata.maxParticipants, cost = _hashMetadata.cost, collectionName = _hashMetadata.collectionName, collectionAddress = _hashMetadata.collectionAddress, startTimestamp = _hashMetadata.startTimestamp, description = _hashMetadata.description, image = _hashMetadata.image;\n              raffles.push({\n                type: type,\n                title: title,\n                id: i,\n                winnersCount: winnersCount,\n                maxParticipants: maxParticipants,\n                cost: cost,\n                image: image,\n                collectionName: collectionName,\n                isParticipant: isParticipant,\n                collectionAddress: collectionAddress,\n                startTimestamp: startTimestamp,\n                endTimestamp: raffle.endTimestamp.toString(),\n                description: description,\n                winners: winners,\n                participants: playersCount\n              });\n\n            case 35:\n              i--;\n              _context.next = 11;\n              break;\n\n            case 38:\n              _context.next = 40;\n              return croRaffle.managers(accountAddress);\n\n            case 40:\n              isManager = _context.sent;\n              _context.next = 43;\n              return croRaffle.owner();\n\n            case 43:\n              owner = _context.sent;\n              if (ethers.utils.getAddress(owner) == ethers.utils.getAddress(accountAddress)) isManager = true;\n              _context.next = 47;\n              return croSkullsGrave.allowance(accountAddress, croRaffle.address);\n\n            case 47:\n              allowance = _context.sent;\n              allowance = allowance.toString();\n              dispatch(fetchRaffleSuccess({\n                raffleCount: raffleCount,\n                init: true,\n                raffles: raffles,\n                allowance: allowance,\n                isManager: isManager\n              }));\n\n            case 50:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n};","map":{"version":3,"sources":["F:/Mattia/Visual studio/ProjectCroSkull/croskull-nft-marketplace/src/redux/raffle/raffleActions.js"],"names":["ethers","store","sendNotification","getSkullsData","fetchRaffleRequest","type","fetchRaffleSuccess","payload","loadRaffleData","dispatch","getState","blockchain","accountAddress","croRaffle","croSkullsGrave","raffleCounter","raffleCount","raffles","toString","i","getRaffle","raffle","getWinners","winners","isParticipant","playersCount","ipfsHash","replace","fetch","hashMetadata","json","title","winnersCount","maxParticipants","cost","collectionName","collectionAddress","startTimestamp","description","image","push","id","endTimestamp","participants","managers","isManager","owner","utils","getAddress","allowance","address","init"],"mappings":"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","sourcesContent":["import { ethers } from \"ethers\";\r\nimport store from \"../store\";\r\nimport { sendNotification, getSkullsData } from \"../data/dataActions\";\r\n\r\nconst fetchRaffleRequest = () => {\r\n  return {\r\n    type: \"FETCH_RAFFLE_REQUEST\",\r\n  };\r\n};\r\n\r\nconst fetchRaffleSuccess = (payload) => {\r\n    return {\r\n      type: \"FETCH_RAFFLE_SUCCESS\",\r\n      payload: payload\r\n    }\r\n}\r\n\r\nexport const loadRaffleData = () => {\r\n    return async (dispatch) => {\r\n        dispatch(fetchRaffleRequest())\r\n        let { accountAddress, croRaffle, croSkullsGrave } = store.getState().blockchain\r\n        let raffleCount = await croRaffle.raffleCounter()\r\n        let raffles = []\r\n        raffleCount = await raffleCount.toString()\r\n        if( raffleCount ) {\r\n            for( let i = raffleCount-1; i > 1; i--){\r\n                if( i <= 1 ) return\r\n                let raffle = await croRaffle.getRaffle(i)\r\n                let winners = await croRaffle.getWinners(i)\r\n\r\n                let isParticipant = await croRaffle.isParticipant(i)\r\n                let playersCount = await raffle.playersCount.toString()\r\n\r\n                let ipfsHash = raffle.ipfsHash.replace('ipfs://', 'https://ipfs.infura.io/ipfs/')\r\n                let hashMetadata = await fetch( ipfsHash );\r\n                hashMetadata = await hashMetadata.json()\r\n                let { type, title, winnersCount, maxParticipants, cost, collectionName, collectionAddress, startTimestamp, description, image } = hashMetadata;\r\n                raffles.push({\r\n                    type, \r\n                    title,\r\n                    id: i,\r\n                    winnersCount,\r\n                    maxParticipants, \r\n                    cost,\r\n                    image,\r\n                    collectionName,\r\n                    isParticipant,\r\n                    collectionAddress,\r\n                    startTimestamp,\r\n                    endTimestamp: raffle.endTimestamp.toString(),\r\n                    description,\r\n                    winners,\r\n                    participants: playersCount\r\n                })\r\n            }\r\n        }\r\n        let isManager = await croRaffle.managers(accountAddress)\r\n        let owner = await croRaffle.owner()\r\n        if(  ethers.utils.getAddress(owner) == ethers.utils.getAddress( accountAddress ) ) \r\n            isManager = true\r\n\r\n        let allowance = await croSkullsGrave.allowance( accountAddress, croRaffle.address )\r\n        allowance = allowance.toString()\r\n\r\n        dispatch(fetchRaffleSuccess( {\r\n            raffleCount,\r\n            init: true,\r\n            raffles,\r\n            allowance,\r\n            isManager\r\n        } ))\r\n    }\r\n}"]},"metadata":{},"sourceType":"module"}