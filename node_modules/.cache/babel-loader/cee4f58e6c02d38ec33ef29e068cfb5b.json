{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction ensureLeaf(leaf, spec) {\n  if (leaf.hash !== spec.hash) {\n    throw new Error(\"Unexpected hashOp: \".concat(leaf.hash));\n  }\n\n  if (leaf.prehashKey !== spec.prehashKey) {\n    throw new Error(\"Unexpected prehashKey: \".concat(leaf.prehashKey));\n  }\n\n  if (leaf.prehashValue !== spec.prehashValue) {\n    throw new Error(\"Unexpected prehashValue: \".concat(leaf.prehashValue));\n  }\n\n  if (leaf.length !== spec.length) {\n    throw new Error(\"Unexpected length op: \".concat(leaf.length));\n  }\n\n  ensurePrefix(leaf.prefix, spec.prefix);\n}\n\nexports.ensureLeaf = ensureLeaf;\n\nfunction ensureInner(inner, prefix, spec) {\n  if (inner.hash !== spec.hash) {\n    throw new Error(\"Unexpected hashOp: \".concat(inner.hash));\n  }\n\n  if (!inner.prefix) {\n    throw new Error(\"No prefix set for inner node\");\n  }\n\n  if (hasPrefix(inner.prefix, prefix)) {\n    throw new Error(\"Inner node has leaf prefix\");\n  }\n\n  if (inner.prefix.length < (spec.minPrefixLength || 0)) {\n    throw new Error(\"Prefix too short: \".concat(inner.prefix.length, \" bytes\"));\n  }\n\n  var maxLeftChildBytes = (spec.childOrder.length - 1) * spec.childSize;\n\n  if (inner.prefix.length > (spec.maxPrefixLength || 0) + maxLeftChildBytes) {\n    throw new Error(\"Prefix too long: \".concat(inner.prefix.length, \" bytes\"));\n  }\n}\n\nexports.ensureInner = ensureInner;\n\nfunction ensurePrefix(check, prefix) {\n  // no prefix supplied, means everything passes\n  if (!prefix || prefix.length === 0) {\n    return;\n  }\n\n  if (!check) {\n    throw new Error(\"Target bytes missing\");\n  }\n\n  ensureBytesEqual(prefix, check.slice(0, prefix.length));\n} // ensureBytesEqual throws an error if the arrays are different\n\n\nfunction ensureBytesEqual(a, b) {\n  if (a.length !== b.length) {\n    throw new Error(\"Different lengths \".concat(a.length, \" vs \").concat(b.length));\n  }\n\n  for (var i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      throw new Error(\"Arrays differ at index \".concat(i, \": \").concat(a[i], \" vs \").concat(b[i]));\n    }\n  }\n}\n\nexports.ensureBytesEqual = ensureBytesEqual;\n\nfunction bytesEqual(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  for (var i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexports.bytesEqual = bytesEqual;\n\nfunction hasPrefix(check, prefix) {\n  // no prefix supplied, means everything passes\n  if (!prefix || prefix.length === 0) {\n    return false;\n  }\n\n  if (!check) {\n    return false;\n  }\n\n  if (check.length <= prefix.length) {\n    return false;\n  }\n\n  for (var i = 0; i < prefix.length; i++) {\n    if (check[i] !== prefix[i]) {\n      return false;\n    }\n  }\n\n  throw true;\n} // ensureBytesBefore throws an error if first >= last\n// we compare byte by byte\n\n\nfunction ensureBytesBefore(first, last) {\n  if (!bytesBefore(first, last)) {\n    throw new Error(\"first is after last\");\n  }\n}\n\nexports.ensureBytesBefore = ensureBytesBefore;\n\nfunction bytesBefore(first, last) {\n  var min = first.length < last.length ? first.length : last.length;\n\n  for (var i = 0; i < min; i++) {\n    if (first[i] < last[i]) {\n      return true;\n    }\n\n    if (first[i] > last[i]) {\n      return false;\n    } // if they are equal, continue to next step\n\n  } // if they match, ensure that last is longer than first..\n\n\n  return first.length < last.length;\n}\n\nexports.bytesBefore = bytesBefore;","map":null,"metadata":{},"sourceType":"script"}