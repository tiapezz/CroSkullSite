{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"F:\\\\Mattia\\\\Visual studio\\\\ProjectCroSkull\\\\croskull-nft-marketplace\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\n\nvar _regeneratorRuntime = require(\"F:\\\\Mattia\\\\Visual studio\\\\ProjectCroSkull\\\\croskull-nft-marketplace\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"F:\\\\Mattia\\\\Visual studio\\\\ProjectCroSkull\\\\croskull-nft-marketplace\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"F:\\\\Mattia\\\\Visual studio\\\\ProjectCroSkull\\\\croskull-nft-marketplace\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"F:\\\\Mattia\\\\Visual studio\\\\ProjectCroSkull\\\\croskull-nft-marketplace\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Tendermint34Client = void 0;\n\nvar jsonrpc_1 = require(\"../jsonrpc\");\n\nvar rpcclients_1 = require(\"../rpcclients\");\n\nvar adaptor_1 = require(\"./adaptor\");\n\nvar requests = __importStar(require(\"./requests\"));\n\nvar Tendermint34Client = /*#__PURE__*/function () {\n  /**\n   * Use `Tendermint34Client.connect` or `Tendermint34Client.create` to create an instance.\n   */\n  function Tendermint34Client(client) {\n    _classCallCheck(this, Tendermint34Client);\n\n    this.client = client;\n    this.p = adaptor_1.adaptor34.params;\n    this.r = adaptor_1.adaptor34.responses;\n  }\n  /**\n   * Creates a new Tendermint client for the given endpoint.\n   *\n   * Uses HTTP when the URL schema is http or https. Uses WebSockets otherwise.\n   */\n\n\n  _createClass(Tendermint34Client, [{\n    key: \"disconnect\",\n    value: function disconnect() {\n      this.client.disconnect();\n    }\n  }, {\n    key: \"abciInfo\",\n    value: function () {\n      var _abciInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var query;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                query = {\n                  method: requests.Method.AbciInfo\n                };\n                return _context.abrupt(\"return\", this.doCall(query, this.p.encodeAbciInfo, this.r.decodeAbciInfo));\n\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function abciInfo() {\n        return _abciInfo.apply(this, arguments);\n      }\n\n      return abciInfo;\n    }()\n  }, {\n    key: \"abciQuery\",\n    value: function () {\n      var _abciQuery = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(params) {\n        var query;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                query = {\n                  params: params,\n                  method: requests.Method.AbciQuery\n                };\n                return _context2.abrupt(\"return\", this.doCall(query, this.p.encodeAbciQuery, this.r.decodeAbciQuery));\n\n              case 2:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function abciQuery(_x) {\n        return _abciQuery.apply(this, arguments);\n      }\n\n      return abciQuery;\n    }()\n  }, {\n    key: \"block\",\n    value: function () {\n      var _block = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(height) {\n        var query;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                query = {\n                  method: requests.Method.Block,\n                  params: {\n                    height: height\n                  }\n                };\n                return _context3.abrupt(\"return\", this.doCall(query, this.p.encodeBlock, this.r.decodeBlock));\n\n              case 2:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function block(_x2) {\n        return _block.apply(this, arguments);\n      }\n\n      return block;\n    }()\n  }, {\n    key: \"blockResults\",\n    value: function () {\n      var _blockResults = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(height) {\n        var query;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                query = {\n                  method: requests.Method.BlockResults,\n                  params: {\n                    height: height\n                  }\n                };\n                return _context4.abrupt(\"return\", this.doCall(query, this.p.encodeBlockResults, this.r.decodeBlockResults));\n\n              case 2:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function blockResults(_x3) {\n        return _blockResults.apply(this, arguments);\n      }\n\n      return blockResults;\n    }()\n    /**\n     * Search for events that are in a block.\n     *\n     * NOTE\n     * This method will error on any node that is running a Tendermint version lower than 0.34.9.\n     *\n     * @see https://docs.tendermint.com/master/rpc/#/Info/block_search\n     */\n\n  }, {\n    key: \"blockSearch\",\n    value: function () {\n      var _blockSearch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(params) {\n        var query, resp;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                query = {\n                  params: params,\n                  method: requests.Method.BlockSearch\n                };\n                _context5.next = 3;\n                return this.doCall(query, this.p.encodeBlockSearch, this.r.decodeBlockSearch);\n\n              case 3:\n                resp = _context5.sent;\n                return _context5.abrupt(\"return\", Object.assign(Object.assign({}, resp), {\n                  // make sure we sort by height, as tendermint may be sorting by string value of the height\n                  blocks: _toConsumableArray(resp.blocks).sort(function (a, b) {\n                    return a.block.header.height - b.block.header.height;\n                  })\n                }));\n\n              case 5:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function blockSearch(_x4) {\n        return _blockSearch.apply(this, arguments);\n      }\n\n      return blockSearch;\n    }() // this should paginate through all blockSearch options to ensure it returns all results.\n    // starts with page 1 or whatever was provided (eg. to start on page 7)\n    //\n    // NOTE\n    // This method will error on any node that is running a Tendermint version lower than 0.34.9.\n\n  }, {\n    key: \"blockSearchAll\",\n    value: function () {\n      var _blockSearchAll = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(params) {\n        var page, blocks, done, resp;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                page = params.page || 1;\n                blocks = [];\n                done = false;\n\n              case 3:\n                if (done) {\n                  _context6.next = 11;\n                  break;\n                }\n\n                _context6.next = 6;\n                return this.blockSearch(Object.assign(Object.assign({}, params), {\n                  page: page\n                }));\n\n              case 6:\n                resp = _context6.sent;\n                blocks.push.apply(blocks, _toConsumableArray(resp.blocks));\n\n                if (blocks.length < resp.totalCount) {\n                  page++;\n                } else {\n                  done = true;\n                }\n\n                _context6.next = 3;\n                break;\n\n              case 11:\n                // make sure we sort by height, as tendermint may be sorting by string value of the height\n                // and the earlier items may be in a higher page than the later items\n                blocks.sort(function (a, b) {\n                  return a.block.header.height - b.block.header.height;\n                });\n                return _context6.abrupt(\"return\", {\n                  totalCount: blocks.length,\n                  blocks: blocks\n                });\n\n              case 13:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function blockSearchAll(_x5) {\n        return _blockSearchAll.apply(this, arguments);\n      }\n\n      return blockSearchAll;\n    }()\n    /**\n     * Queries block headers filtered by minHeight <= height <= maxHeight.\n     *\n     * @param minHeight The minimum height to be included in the result. Defaults to 0.\n     * @param maxHeight The maximum height to be included in the result. Defaults to infinity.\n     */\n\n  }, {\n    key: \"blockchain\",\n    value: function () {\n      var _blockchain = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(minHeight, maxHeight) {\n        var query;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                query = {\n                  method: requests.Method.Blockchain,\n                  params: {\n                    minHeight: minHeight,\n                    maxHeight: maxHeight\n                  }\n                };\n                return _context7.abrupt(\"return\", this.doCall(query, this.p.encodeBlockchain, this.r.decodeBlockchain));\n\n              case 2:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function blockchain(_x6, _x7) {\n        return _blockchain.apply(this, arguments);\n      }\n\n      return blockchain;\n    }()\n    /**\n     * Broadcast transaction to mempool and wait for response\n     *\n     * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_sync\n     */\n\n  }, {\n    key: \"broadcastTxSync\",\n    value: function () {\n      var _broadcastTxSync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(params) {\n        var query;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                query = {\n                  params: params,\n                  method: requests.Method.BroadcastTxSync\n                };\n                return _context8.abrupt(\"return\", this.doCall(query, this.p.encodeBroadcastTx, this.r.decodeBroadcastTxSync));\n\n              case 2:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function broadcastTxSync(_x8) {\n        return _broadcastTxSync.apply(this, arguments);\n      }\n\n      return broadcastTxSync;\n    }()\n    /**\n     * Broadcast transaction to mempool and do not wait for result\n     *\n     * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_async\n     */\n\n  }, {\n    key: \"broadcastTxAsync\",\n    value: function () {\n      var _broadcastTxAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(params) {\n        var query;\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                query = {\n                  params: params,\n                  method: requests.Method.BroadcastTxAsync\n                };\n                return _context9.abrupt(\"return\", this.doCall(query, this.p.encodeBroadcastTx, this.r.decodeBroadcastTxAsync));\n\n              case 2:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function broadcastTxAsync(_x9) {\n        return _broadcastTxAsync.apply(this, arguments);\n      }\n\n      return broadcastTxAsync;\n    }()\n    /**\n     * Broadcast transaction to mempool and wait for block\n     *\n     * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_commit\n     */\n\n  }, {\n    key: \"broadcastTxCommit\",\n    value: function () {\n      var _broadcastTxCommit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(params) {\n        var query;\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                query = {\n                  params: params,\n                  method: requests.Method.BroadcastTxCommit\n                };\n                return _context10.abrupt(\"return\", this.doCall(query, this.p.encodeBroadcastTx, this.r.decodeBroadcastTxCommit));\n\n              case 2:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function broadcastTxCommit(_x10) {\n        return _broadcastTxCommit.apply(this, arguments);\n      }\n\n      return broadcastTxCommit;\n    }()\n  }, {\n    key: \"commit\",\n    value: function () {\n      var _commit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(height) {\n        var query;\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                query = {\n                  method: requests.Method.Commit,\n                  params: {\n                    height: height\n                  }\n                };\n                return _context11.abrupt(\"return\", this.doCall(query, this.p.encodeCommit, this.r.decodeCommit));\n\n              case 2:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function commit(_x11) {\n        return _commit.apply(this, arguments);\n      }\n\n      return commit;\n    }()\n  }, {\n    key: \"genesis\",\n    value: function () {\n      var _genesis = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12() {\n        var query;\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                query = {\n                  method: requests.Method.Genesis\n                };\n                return _context12.abrupt(\"return\", this.doCall(query, this.p.encodeGenesis, this.r.decodeGenesis));\n\n              case 2:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function genesis() {\n        return _genesis.apply(this, arguments);\n      }\n\n      return genesis;\n    }()\n  }, {\n    key: \"health\",\n    value: function () {\n      var _health = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13() {\n        var query;\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                query = {\n                  method: requests.Method.Health\n                };\n                return _context13.abrupt(\"return\", this.doCall(query, this.p.encodeHealth, this.r.decodeHealth));\n\n              case 2:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function health() {\n        return _health.apply(this, arguments);\n      }\n\n      return health;\n    }()\n  }, {\n    key: \"status\",\n    value: function () {\n      var _status = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14() {\n        var query;\n        return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                query = {\n                  method: requests.Method.Status\n                };\n                return _context14.abrupt(\"return\", this.doCall(query, this.p.encodeStatus, this.r.decodeStatus));\n\n              case 2:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      function status() {\n        return _status.apply(this, arguments);\n      }\n\n      return status;\n    }()\n  }, {\n    key: \"subscribeNewBlock\",\n    value: function subscribeNewBlock() {\n      var request = {\n        method: requests.Method.Subscribe,\n        query: {\n          type: requests.SubscriptionEventType.NewBlock\n        }\n      };\n      return this.subscribe(request, this.r.decodeNewBlockEvent);\n    }\n  }, {\n    key: \"subscribeNewBlockHeader\",\n    value: function subscribeNewBlockHeader() {\n      var request = {\n        method: requests.Method.Subscribe,\n        query: {\n          type: requests.SubscriptionEventType.NewBlockHeader\n        }\n      };\n      return this.subscribe(request, this.r.decodeNewBlockHeaderEvent);\n    }\n  }, {\n    key: \"subscribeTx\",\n    value: function subscribeTx(query) {\n      var request = {\n        method: requests.Method.Subscribe,\n        query: {\n          type: requests.SubscriptionEventType.Tx,\n          raw: query\n        }\n      };\n      return this.subscribe(request, this.r.decodeTxEvent);\n    }\n    /**\n     * Get a single transaction by hash\n     *\n     * @see https://docs.tendermint.com/master/rpc/#/Info/tx\n     */\n\n  }, {\n    key: \"tx\",\n    value: function () {\n      var _tx = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee15(params) {\n        var query;\n        return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                query = {\n                  params: params,\n                  method: requests.Method.Tx\n                };\n                return _context15.abrupt(\"return\", this.doCall(query, this.p.encodeTx, this.r.decodeTx));\n\n              case 2:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n\n      function tx(_x12) {\n        return _tx.apply(this, arguments);\n      }\n\n      return tx;\n    }()\n    /**\n     * Search for transactions that are in a block\n     *\n     * @see https://docs.tendermint.com/master/rpc/#/Info/tx_search\n     */\n\n  }, {\n    key: \"txSearch\",\n    value: function () {\n      var _txSearch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee16(params) {\n        var query;\n        return _regeneratorRuntime.wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                query = {\n                  params: params,\n                  method: requests.Method.TxSearch\n                };\n                return _context16.abrupt(\"return\", this.doCall(query, this.p.encodeTxSearch, this.r.decodeTxSearch));\n\n              case 2:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n\n      function txSearch(_x13) {\n        return _txSearch.apply(this, arguments);\n      }\n\n      return txSearch;\n    }() // this should paginate through all txSearch options to ensure it returns all results.\n    // starts with page 1 or whatever was provided (eg. to start on page 7)\n\n  }, {\n    key: \"txSearchAll\",\n    value: function () {\n      var _txSearchAll = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee17(params) {\n        var page, txs, done, resp;\n        return _regeneratorRuntime.wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                page = params.page || 1;\n                txs = [];\n                done = false;\n\n              case 3:\n                if (done) {\n                  _context17.next = 11;\n                  break;\n                }\n\n                _context17.next = 6;\n                return this.txSearch(Object.assign(Object.assign({}, params), {\n                  page: page\n                }));\n\n              case 6:\n                resp = _context17.sent;\n                txs.push.apply(txs, _toConsumableArray(resp.txs));\n\n                if (txs.length < resp.totalCount) {\n                  page++;\n                } else {\n                  done = true;\n                }\n\n                _context17.next = 3;\n                break;\n\n              case 11:\n                return _context17.abrupt(\"return\", {\n                  totalCount: txs.length,\n                  txs: txs\n                });\n\n              case 12:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n\n      function txSearchAll(_x14) {\n        return _txSearchAll.apply(this, arguments);\n      }\n\n      return txSearchAll;\n    }()\n  }, {\n    key: \"validators\",\n    value: function () {\n      var _validators = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee18(params) {\n        var query;\n        return _regeneratorRuntime.wrap(function _callee18$(_context18) {\n          while (1) {\n            switch (_context18.prev = _context18.next) {\n              case 0:\n                query = {\n                  method: requests.Method.Validators,\n                  params: params\n                };\n                return _context18.abrupt(\"return\", this.doCall(query, this.p.encodeValidators, this.r.decodeValidators));\n\n              case 2:\n              case \"end\":\n                return _context18.stop();\n            }\n          }\n        }, _callee18, this);\n      }));\n\n      function validators(_x15) {\n        return _validators.apply(this, arguments);\n      }\n\n      return validators;\n    }()\n  }, {\n    key: \"validatorsAll\",\n    value: function () {\n      var _validatorsAll = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee19(height) {\n        var validators, page, done, blockHeight, response;\n        return _regeneratorRuntime.wrap(function _callee19$(_context19) {\n          while (1) {\n            switch (_context19.prev = _context19.next) {\n              case 0:\n                validators = [];\n                page = 1;\n                done = false;\n                blockHeight = height;\n\n              case 4:\n                if (done) {\n                  _context19.next = 13;\n                  break;\n                }\n\n                _context19.next = 7;\n                return this.validators({\n                  per_page: 50,\n                  height: blockHeight,\n                  page: page\n                });\n\n              case 7:\n                response = _context19.sent;\n                validators.push.apply(validators, _toConsumableArray(response.validators));\n                blockHeight = blockHeight || response.blockHeight;\n\n                if (validators.length < response.total) {\n                  page++;\n                } else {\n                  done = true;\n                }\n\n                _context19.next = 4;\n                break;\n\n              case 13:\n                return _context19.abrupt(\"return\", {\n                  // NOTE: Default value is for type safety but this should always be set\n                  blockHeight: blockHeight !== null && blockHeight !== void 0 ? blockHeight : 0,\n                  count: validators.length,\n                  total: validators.length,\n                  validators: validators\n                });\n\n              case 14:\n              case \"end\":\n                return _context19.stop();\n            }\n          }\n        }, _callee19, this);\n      }));\n\n      function validatorsAll(_x16) {\n        return _validatorsAll.apply(this, arguments);\n      }\n\n      return validatorsAll;\n    }() // doCall is a helper to handle the encode/call/decode logic\n\n  }, {\n    key: \"doCall\",\n    value: function () {\n      var _doCall = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee20(request, encode, decode) {\n        var req, result;\n        return _regeneratorRuntime.wrap(function _callee20$(_context20) {\n          while (1) {\n            switch (_context20.prev = _context20.next) {\n              case 0:\n                req = encode(request);\n                _context20.next = 3;\n                return this.client.execute(req);\n\n              case 3:\n                result = _context20.sent;\n                return _context20.abrupt(\"return\", decode(result));\n\n              case 5:\n              case \"end\":\n                return _context20.stop();\n            }\n          }\n        }, _callee20, this);\n      }));\n\n      function doCall(_x17, _x18, _x19) {\n        return _doCall.apply(this, arguments);\n      }\n\n      return doCall;\n    }()\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(request, decode) {\n      if (!rpcclients_1.instanceOfRpcStreamingClient(this.client)) {\n        throw new Error(\"This RPC client type cannot subscribe to events\");\n      }\n\n      var req = this.p.encodeSubscribe(request);\n      var eventStream = this.client.listen(req);\n      return eventStream.map(function (event) {\n        return decode(event);\n      });\n    }\n  }], [{\n    key: \"connect\",\n    value: function () {\n      var _connect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee21(url) {\n        var useHttp, rpcClient;\n        return _regeneratorRuntime.wrap(function _callee21$(_context21) {\n          while (1) {\n            switch (_context21.prev = _context21.next) {\n              case 0:\n                useHttp = url.startsWith(\"http://\") || url.startsWith(\"https://\");\n                rpcClient = useHttp ? new rpcclients_1.HttpClient(url) : new rpcclients_1.WebsocketClient(url);\n                return _context21.abrupt(\"return\", Tendermint34Client.create(rpcClient));\n\n              case 3:\n              case \"end\":\n                return _context21.stop();\n            }\n          }\n        }, _callee21);\n      }));\n\n      function connect(_x20) {\n        return _connect.apply(this, arguments);\n      }\n\n      return connect;\n    }()\n    /**\n     * Creates a new Tendermint client given an RPC client.\n     */\n\n  }, {\n    key: \"create\",\n    value: function () {\n      var _create = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee22(rpcClient) {\n        var _version;\n\n        return _regeneratorRuntime.wrap(function _callee22$(_context22) {\n          while (1) {\n            switch (_context22.prev = _context22.next) {\n              case 0:\n                _context22.next = 2;\n                return this.detectVersion(rpcClient);\n\n              case 2:\n                _version = _context22.sent;\n                return _context22.abrupt(\"return\", new Tendermint34Client(rpcClient));\n\n              case 4:\n              case \"end\":\n                return _context22.stop();\n            }\n          }\n        }, _callee22, this);\n      }));\n\n      function create(_x21) {\n        return _create.apply(this, arguments);\n      }\n\n      return create;\n    }()\n  }, {\n    key: \"detectVersion\",\n    value: function () {\n      var _detectVersion = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee23(client) {\n        var req, response, result, version;\n        return _regeneratorRuntime.wrap(function _callee23$(_context23) {\n          while (1) {\n            switch (_context23.prev = _context23.next) {\n              case 0:\n                req = jsonrpc_1.createJsonRpcRequest(requests.Method.Status);\n                _context23.next = 3;\n                return client.execute(req);\n\n              case 3:\n                response = _context23.sent;\n                result = response.result;\n\n                if (!(!result || !result.node_info)) {\n                  _context23.next = 7;\n                  break;\n                }\n\n                throw new Error(\"Unrecognized format for status response\");\n\n              case 7:\n                version = result.node_info.version;\n\n                if (!(typeof version !== \"string\")) {\n                  _context23.next = 10;\n                  break;\n                }\n\n                throw new Error(\"Unrecognized version format: must be string\");\n\n              case 10:\n                return _context23.abrupt(\"return\", version);\n\n              case 11:\n              case \"end\":\n                return _context23.stop();\n            }\n          }\n        }, _callee23);\n      }));\n\n      function detectVersion(_x22) {\n        return _detectVersion.apply(this, arguments);\n      }\n\n      return detectVersion;\n    }()\n  }]);\n\n  return Tendermint34Client;\n}();\n\nexports.Tendermint34Client = Tendermint34Client;","map":null,"metadata":{},"sourceType":"script"}