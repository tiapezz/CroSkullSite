{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NO_IL = exports.NO = exports.MemoryStream = exports.Stream = void 0;\n\nvar ponyfill_1 = require(\"symbol-observable/ponyfill\");\n\nvar globalthis_1 = require(\"globalthis\");\n\nvar $$observable = ponyfill_1.default(globalthis_1.getPolyfill());\nvar NO = {};\nexports.NO = NO;\n\nfunction noop() {}\n\nfunction cp(a) {\n  var l = a.length;\n  var b = Array(l);\n\n  for (var i = 0; i < l; ++i) {\n    b[i] = a[i];\n  }\n\n  return b;\n}\n\nfunction and(f1, f2) {\n  return function andFn(t) {\n    return f1(t) && f2(t);\n  };\n}\n\nfunction _try(c, t, u) {\n  try {\n    return c.f(t);\n  } catch (e) {\n    u._e(e);\n\n    return NO;\n  }\n}\n\nvar NO_IL = {\n  _n: noop,\n  _e: noop,\n  _c: noop\n};\nexports.NO_IL = NO_IL; // mutates the input\n\nfunction internalizeProducer(producer) {\n  producer._start = function _start(il) {\n    il.next = il._n;\n    il.error = il._e;\n    il.complete = il._c;\n    this.start(il);\n  };\n\n  producer._stop = producer.stop;\n}\n\nvar StreamSub =\n/** @class */\nfunction () {\n  function StreamSub(_stream, _listener) {\n    this._stream = _stream;\n    this._listener = _listener;\n  }\n\n  StreamSub.prototype.unsubscribe = function () {\n    this._stream._remove(this._listener);\n  };\n\n  return StreamSub;\n}();\n\nvar Observer =\n/** @class */\nfunction () {\n  function Observer(_listener) {\n    this._listener = _listener;\n  }\n\n  Observer.prototype.next = function (value) {\n    this._listener._n(value);\n  };\n\n  Observer.prototype.error = function (err) {\n    this._listener._e(err);\n  };\n\n  Observer.prototype.complete = function () {\n    this._listener._c();\n  };\n\n  return Observer;\n}();\n\nvar FromObservable =\n/** @class */\nfunction () {\n  function FromObservable(observable) {\n    this.type = 'fromObservable';\n    this.ins = observable;\n    this.active = false;\n  }\n\n  FromObservable.prototype._start = function (out) {\n    this.out = out;\n    this.active = true;\n    this._sub = this.ins.subscribe(new Observer(out));\n    if (!this.active) this._sub.unsubscribe();\n  };\n\n  FromObservable.prototype._stop = function () {\n    if (this._sub) this._sub.unsubscribe();\n    this.active = false;\n  };\n\n  return FromObservable;\n}();\n\nvar Merge =\n/** @class */\nfunction () {\n  function Merge(insArr) {\n    this.type = 'merge';\n    this.insArr = insArr;\n    this.out = NO;\n    this.ac = 0;\n  }\n\n  Merge.prototype._start = function (out) {\n    this.out = out;\n    var s = this.insArr;\n    var L = s.length;\n    this.ac = L;\n\n    for (var i = 0; i < L; i++) {\n      s[i]._add(this);\n    }\n  };\n\n  Merge.prototype._stop = function () {\n    var s = this.insArr;\n    var L = s.length;\n\n    for (var i = 0; i < L; i++) {\n      s[i]._remove(this);\n    }\n\n    this.out = NO;\n  };\n\n  Merge.prototype._n = function (t) {\n    var u = this.out;\n    if (u === NO) return;\n\n    u._n(t);\n  };\n\n  Merge.prototype._e = function (err) {\n    var u = this.out;\n    if (u === NO) return;\n\n    u._e(err);\n  };\n\n  Merge.prototype._c = function () {\n    if (--this.ac <= 0) {\n      var u = this.out;\n      if (u === NO) return;\n\n      u._c();\n    }\n  };\n\n  return Merge;\n}();\n\nvar CombineListener =\n/** @class */\nfunction () {\n  function CombineListener(i, out, p) {\n    this.i = i;\n    this.out = out;\n    this.p = p;\n    p.ils.push(this);\n  }\n\n  CombineListener.prototype._n = function (t) {\n    var p = this.p,\n        out = this.out;\n    if (out === NO) return;\n\n    if (p.up(t, this.i)) {\n      var b = cp(p.vals);\n\n      out._n(b);\n    }\n  };\n\n  CombineListener.prototype._e = function (err) {\n    var out = this.out;\n    if (out === NO) return;\n\n    out._e(err);\n  };\n\n  CombineListener.prototype._c = function () {\n    var p = this.p;\n    if (p.out === NO) return;\n    if (--p.Nc === 0) p.out._c();\n  };\n\n  return CombineListener;\n}();\n\nvar Combine =\n/** @class */\nfunction () {\n  function Combine(insArr) {\n    this.type = 'combine';\n    this.insArr = insArr;\n    this.out = NO;\n    this.ils = [];\n    this.Nc = this.Nn = 0;\n    this.vals = [];\n  }\n\n  Combine.prototype.up = function (t, i) {\n    var v = this.vals[i];\n    var Nn = !this.Nn ? 0 : v === NO ? --this.Nn : this.Nn;\n    this.vals[i] = t;\n    return Nn === 0;\n  };\n\n  Combine.prototype._start = function (out) {\n    this.out = out;\n    var s = this.insArr;\n    var n = this.Nc = this.Nn = s.length;\n    var vals = this.vals = new Array(n);\n\n    if (n === 0) {\n      out._n([]);\n\n      out._c();\n    } else {\n      for (var i = 0; i < n; i++) {\n        vals[i] = NO;\n\n        s[i]._add(new CombineListener(i, out, this));\n      }\n    }\n  };\n\n  Combine.prototype._stop = function () {\n    var s = this.insArr;\n    var n = s.length;\n    var ils = this.ils;\n\n    for (var i = 0; i < n; i++) {\n      s[i]._remove(ils[i]);\n    }\n\n    this.out = NO;\n    this.ils = [];\n    this.vals = [];\n  };\n\n  return Combine;\n}();\n\nvar FromArray =\n/** @class */\nfunction () {\n  function FromArray(a) {\n    this.type = 'fromArray';\n    this.a = a;\n  }\n\n  FromArray.prototype._start = function (out) {\n    var a = this.a;\n\n    for (var i = 0, n = a.length; i < n; i++) {\n      out._n(a[i]);\n    }\n\n    out._c();\n  };\n\n  FromArray.prototype._stop = function () {};\n\n  return FromArray;\n}();\n\nvar FromPromise =\n/** @class */\nfunction () {\n  function FromPromise(p) {\n    this.type = 'fromPromise';\n    this.on = false;\n    this.p = p;\n  }\n\n  FromPromise.prototype._start = function (out) {\n    var prod = this;\n    this.on = true;\n    this.p.then(function (v) {\n      if (prod.on) {\n        out._n(v);\n\n        out._c();\n      }\n    }, function (e) {\n      out._e(e);\n    }).then(noop, function (err) {\n      setTimeout(function () {\n        throw err;\n      });\n    });\n  };\n\n  FromPromise.prototype._stop = function () {\n    this.on = false;\n  };\n\n  return FromPromise;\n}();\n\nvar Periodic =\n/** @class */\nfunction () {\n  function Periodic(period) {\n    this.type = 'periodic';\n    this.period = period;\n    this.intervalID = -1;\n    this.i = 0;\n  }\n\n  Periodic.prototype._start = function (out) {\n    var self = this;\n\n    function intervalHandler() {\n      out._n(self.i++);\n    }\n\n    this.intervalID = setInterval(intervalHandler, this.period);\n  };\n\n  Periodic.prototype._stop = function () {\n    if (this.intervalID !== -1) clearInterval(this.intervalID);\n    this.intervalID = -1;\n    this.i = 0;\n  };\n\n  return Periodic;\n}();\n\nvar Debug =\n/** @class */\nfunction () {\n  function Debug(ins, arg) {\n    this.type = 'debug';\n    this.ins = ins;\n    this.out = NO;\n    this.s = noop;\n    this.l = '';\n    if (typeof arg === 'string') this.l = arg;else if (typeof arg === 'function') this.s = arg;\n  }\n\n  Debug.prototype._start = function (out) {\n    this.out = out;\n\n    this.ins._add(this);\n  };\n\n  Debug.prototype._stop = function () {\n    this.ins._remove(this);\n\n    this.out = NO;\n  };\n\n  Debug.prototype._n = function (t) {\n    var u = this.out;\n    if (u === NO) return;\n    var s = this.s,\n        l = this.l;\n\n    if (s !== noop) {\n      try {\n        s(t);\n      } catch (e) {\n        u._e(e);\n      }\n    } else if (l) console.log(l + ':', t);else console.log(t);\n\n    u._n(t);\n  };\n\n  Debug.prototype._e = function (err) {\n    var u = this.out;\n    if (u === NO) return;\n\n    u._e(err);\n  };\n\n  Debug.prototype._c = function () {\n    var u = this.out;\n    if (u === NO) return;\n\n    u._c();\n  };\n\n  return Debug;\n}();\n\nvar Drop =\n/** @class */\nfunction () {\n  function Drop(max, ins) {\n    this.type = 'drop';\n    this.ins = ins;\n    this.out = NO;\n    this.max = max;\n    this.dropped = 0;\n  }\n\n  Drop.prototype._start = function (out) {\n    this.out = out;\n    this.dropped = 0;\n\n    this.ins._add(this);\n  };\n\n  Drop.prototype._stop = function () {\n    this.ins._remove(this);\n\n    this.out = NO;\n  };\n\n  Drop.prototype._n = function (t) {\n    var u = this.out;\n    if (u === NO) return;\n    if (this.dropped++ >= this.max) u._n(t);\n  };\n\n  Drop.prototype._e = function (err) {\n    var u = this.out;\n    if (u === NO) return;\n\n    u._e(err);\n  };\n\n  Drop.prototype._c = function () {\n    var u = this.out;\n    if (u === NO) return;\n\n    u._c();\n  };\n\n  return Drop;\n}();\n\nvar EndWhenListener =\n/** @class */\nfunction () {\n  function EndWhenListener(out, op) {\n    this.out = out;\n    this.op = op;\n  }\n\n  EndWhenListener.prototype._n = function () {\n    this.op.end();\n  };\n\n  EndWhenListener.prototype._e = function (err) {\n    this.out._e(err);\n  };\n\n  EndWhenListener.prototype._c = function () {\n    this.op.end();\n  };\n\n  return EndWhenListener;\n}();\n\nvar EndWhen =\n/** @class */\nfunction () {\n  function EndWhen(o, ins) {\n    this.type = 'endWhen';\n    this.ins = ins;\n    this.out = NO;\n    this.o = o;\n    this.oil = NO_IL;\n  }\n\n  EndWhen.prototype._start = function (out) {\n    this.out = out;\n\n    this.o._add(this.oil = new EndWhenListener(out, this));\n\n    this.ins._add(this);\n  };\n\n  EndWhen.prototype._stop = function () {\n    this.ins._remove(this);\n\n    this.o._remove(this.oil);\n\n    this.out = NO;\n    this.oil = NO_IL;\n  };\n\n  EndWhen.prototype.end = function () {\n    var u = this.out;\n    if (u === NO) return;\n\n    u._c();\n  };\n\n  EndWhen.prototype._n = function (t) {\n    var u = this.out;\n    if (u === NO) return;\n\n    u._n(t);\n  };\n\n  EndWhen.prototype._e = function (err) {\n    var u = this.out;\n    if (u === NO) return;\n\n    u._e(err);\n  };\n\n  EndWhen.prototype._c = function () {\n    this.end();\n  };\n\n  return EndWhen;\n}();\n\nvar Filter =\n/** @class */\nfunction () {\n  function Filter(passes, ins) {\n    this.type = 'filter';\n    this.ins = ins;\n    this.out = NO;\n    this.f = passes;\n  }\n\n  Filter.prototype._start = function (out) {\n    this.out = out;\n\n    this.ins._add(this);\n  };\n\n  Filter.prototype._stop = function () {\n    this.ins._remove(this);\n\n    this.out = NO;\n  };\n\n  Filter.prototype._n = function (t) {\n    var u = this.out;\n    if (u === NO) return;\n\n    var r = _try(this, t, u);\n\n    if (r === NO || !r) return;\n\n    u._n(t);\n  };\n\n  Filter.prototype._e = function (err) {\n    var u = this.out;\n    if (u === NO) return;\n\n    u._e(err);\n  };\n\n  Filter.prototype._c = function () {\n    var u = this.out;\n    if (u === NO) return;\n\n    u._c();\n  };\n\n  return Filter;\n}();\n\nvar FlattenListener =\n/** @class */\nfunction () {\n  function FlattenListener(out, op) {\n    this.out = out;\n    this.op = op;\n  }\n\n  FlattenListener.prototype._n = function (t) {\n    this.out._n(t);\n  };\n\n  FlattenListener.prototype._e = function (err) {\n    this.out._e(err);\n  };\n\n  FlattenListener.prototype._c = function () {\n    this.op.inner = NO;\n    this.op.less();\n  };\n\n  return FlattenListener;\n}();\n\nvar Flatten =\n/** @class */\nfunction () {\n  function Flatten(ins) {\n    this.type = 'flatten';\n    this.ins = ins;\n    this.out = NO;\n    this.open = true;\n    this.inner = NO;\n    this.il = NO_IL;\n  }\n\n  Flatten.prototype._start = function (out) {\n    this.out = out;\n    this.open = true;\n    this.inner = NO;\n    this.il = NO_IL;\n\n    this.ins._add(this);\n  };\n\n  Flatten.prototype._stop = function () {\n    this.ins._remove(this);\n\n    if (this.inner !== NO) this.inner._remove(this.il);\n    this.out = NO;\n    this.open = true;\n    this.inner = NO;\n    this.il = NO_IL;\n  };\n\n  Flatten.prototype.less = function () {\n    var u = this.out;\n    if (u === NO) return;\n    if (!this.open && this.inner === NO) u._c();\n  };\n\n  Flatten.prototype._n = function (s) {\n    var u = this.out;\n    if (u === NO) return;\n\n    var _a = this,\n        inner = _a.inner,\n        il = _a.il;\n\n    if (inner !== NO && il !== NO_IL) inner._remove(il);\n\n    (this.inner = s)._add(this.il = new FlattenListener(u, this));\n  };\n\n  Flatten.prototype._e = function (err) {\n    var u = this.out;\n    if (u === NO) return;\n\n    u._e(err);\n  };\n\n  Flatten.prototype._c = function () {\n    this.open = false;\n    this.less();\n  };\n\n  return Flatten;\n}();\n\nvar Fold =\n/** @class */\nfunction () {\n  function Fold(f, seed, ins) {\n    var _this = this;\n\n    this.type = 'fold';\n    this.ins = ins;\n    this.out = NO;\n\n    this.f = function (t) {\n      return f(_this.acc, t);\n    };\n\n    this.acc = this.seed = seed;\n  }\n\n  Fold.prototype._start = function (out) {\n    this.out = out;\n    this.acc = this.seed;\n\n    out._n(this.acc);\n\n    this.ins._add(this);\n  };\n\n  Fold.prototype._stop = function () {\n    this.ins._remove(this);\n\n    this.out = NO;\n    this.acc = this.seed;\n  };\n\n  Fold.prototype._n = function (t) {\n    var u = this.out;\n    if (u === NO) return;\n\n    var r = _try(this, t, u);\n\n    if (r === NO) return;\n\n    u._n(this.acc = r);\n  };\n\n  Fold.prototype._e = function (err) {\n    var u = this.out;\n    if (u === NO) return;\n\n    u._e(err);\n  };\n\n  Fold.prototype._c = function () {\n    var u = this.out;\n    if (u === NO) return;\n\n    u._c();\n  };\n\n  return Fold;\n}();\n\nvar Last =\n/** @class */\nfunction () {\n  function Last(ins) {\n    this.type = 'last';\n    this.ins = ins;\n    this.out = NO;\n    this.has = false;\n    this.val = NO;\n  }\n\n  Last.prototype._start = function (out) {\n    this.out = out;\n    this.has = false;\n\n    this.ins._add(this);\n  };\n\n  Last.prototype._stop = function () {\n    this.ins._remove(this);\n\n    this.out = NO;\n    this.val = NO;\n  };\n\n  Last.prototype._n = function (t) {\n    this.has = true;\n    this.val = t;\n  };\n\n  Last.prototype._e = function (err) {\n    var u = this.out;\n    if (u === NO) return;\n\n    u._e(err);\n  };\n\n  Last.prototype._c = function () {\n    var u = this.out;\n    if (u === NO) return;\n\n    if (this.has) {\n      u._n(this.val);\n\n      u._c();\n    } else u._e(new Error('last() failed because input stream completed'));\n  };\n\n  return Last;\n}();\n\nvar MapOp =\n/** @class */\nfunction () {\n  function MapOp(project, ins) {\n    this.type = 'map';\n    this.ins = ins;\n    this.out = NO;\n    this.f = project;\n  }\n\n  MapOp.prototype._start = function (out) {\n    this.out = out;\n\n    this.ins._add(this);\n  };\n\n  MapOp.prototype._stop = function () {\n    this.ins._remove(this);\n\n    this.out = NO;\n  };\n\n  MapOp.prototype._n = function (t) {\n    var u = this.out;\n    if (u === NO) return;\n\n    var r = _try(this, t, u);\n\n    if (r === NO) return;\n\n    u._n(r);\n  };\n\n  MapOp.prototype._e = function (err) {\n    var u = this.out;\n    if (u === NO) return;\n\n    u._e(err);\n  };\n\n  MapOp.prototype._c = function () {\n    var u = this.out;\n    if (u === NO) return;\n\n    u._c();\n  };\n\n  return MapOp;\n}();\n\nvar Remember =\n/** @class */\nfunction () {\n  function Remember(ins) {\n    this.type = 'remember';\n    this.ins = ins;\n    this.out = NO;\n  }\n\n  Remember.prototype._start = function (out) {\n    this.out = out;\n\n    this.ins._add(out);\n  };\n\n  Remember.prototype._stop = function () {\n    this.ins._remove(this.out);\n\n    this.out = NO;\n  };\n\n  return Remember;\n}();\n\nvar ReplaceError =\n/** @class */\nfunction () {\n  function ReplaceError(replacer, ins) {\n    this.type = 'replaceError';\n    this.ins = ins;\n    this.out = NO;\n    this.f = replacer;\n  }\n\n  ReplaceError.prototype._start = function (out) {\n    this.out = out;\n\n    this.ins._add(this);\n  };\n\n  ReplaceError.prototype._stop = function () {\n    this.ins._remove(this);\n\n    this.out = NO;\n  };\n\n  ReplaceError.prototype._n = function (t) {\n    var u = this.out;\n    if (u === NO) return;\n\n    u._n(t);\n  };\n\n  ReplaceError.prototype._e = function (err) {\n    var u = this.out;\n    if (u === NO) return;\n\n    try {\n      this.ins._remove(this);\n\n      (this.ins = this.f(err))._add(this);\n    } catch (e) {\n      u._e(e);\n    }\n  };\n\n  ReplaceError.prototype._c = function () {\n    var u = this.out;\n    if (u === NO) return;\n\n    u._c();\n  };\n\n  return ReplaceError;\n}();\n\nvar StartWith =\n/** @class */\nfunction () {\n  function StartWith(ins, val) {\n    this.type = 'startWith';\n    this.ins = ins;\n    this.out = NO;\n    this.val = val;\n  }\n\n  StartWith.prototype._start = function (out) {\n    this.out = out;\n\n    this.out._n(this.val);\n\n    this.ins._add(out);\n  };\n\n  StartWith.prototype._stop = function () {\n    this.ins._remove(this.out);\n\n    this.out = NO;\n  };\n\n  return StartWith;\n}();\n\nvar Take =\n/** @class */\nfunction () {\n  function Take(max, ins) {\n    this.type = 'take';\n    this.ins = ins;\n    this.out = NO;\n    this.max = max;\n    this.taken = 0;\n  }\n\n  Take.prototype._start = function (out) {\n    this.out = out;\n    this.taken = 0;\n    if (this.max <= 0) out._c();else this.ins._add(this);\n  };\n\n  Take.prototype._stop = function () {\n    this.ins._remove(this);\n\n    this.out = NO;\n  };\n\n  Take.prototype._n = function (t) {\n    var u = this.out;\n    if (u === NO) return;\n    var m = ++this.taken;\n    if (m < this.max) u._n(t);else if (m === this.max) {\n      u._n(t);\n\n      u._c();\n    }\n  };\n\n  Take.prototype._e = function (err) {\n    var u = this.out;\n    if (u === NO) return;\n\n    u._e(err);\n  };\n\n  Take.prototype._c = function () {\n    var u = this.out;\n    if (u === NO) return;\n\n    u._c();\n  };\n\n  return Take;\n}();\n\nvar Stream =\n/** @class */\nfunction () {\n  function Stream(producer) {\n    this._prod = producer || NO;\n    this._ils = [];\n    this._stopID = NO;\n    this._dl = NO;\n    this._d = false;\n    this._target = null;\n    this._err = NO;\n  }\n\n  Stream.prototype._n = function (t) {\n    var a = this._ils;\n    var L = a.length;\n    if (this._d) this._dl._n(t);\n    if (L == 1) a[0]._n(t);else if (L == 0) return;else {\n      var b = cp(a);\n\n      for (var i = 0; i < L; i++) {\n        b[i]._n(t);\n      }\n    }\n  };\n\n  Stream.prototype._e = function (err) {\n    if (this._err !== NO) return;\n    this._err = err;\n    var a = this._ils;\n    var L = a.length;\n\n    this._x();\n\n    if (this._d) this._dl._e(err);\n    if (L == 1) a[0]._e(err);else if (L == 0) return;else {\n      var b = cp(a);\n\n      for (var i = 0; i < L; i++) {\n        b[i]._e(err);\n      }\n    }\n    if (!this._d && L == 0) throw this._err;\n  };\n\n  Stream.prototype._c = function () {\n    var a = this._ils;\n    var L = a.length;\n\n    this._x();\n\n    if (this._d) this._dl._c();\n    if (L == 1) a[0]._c();else if (L == 0) return;else {\n      var b = cp(a);\n\n      for (var i = 0; i < L; i++) {\n        b[i]._c();\n      }\n    }\n  };\n\n  Stream.prototype._x = function () {\n    if (this._ils.length === 0) return;\n    if (this._prod !== NO) this._prod._stop();\n    this._err = NO;\n    this._ils = [];\n  };\n\n  Stream.prototype._stopNow = function () {\n    // WARNING: code that calls this method should\n    // first check if this._prod is valid (not `NO`)\n    this._prod._stop();\n\n    this._err = NO;\n    this._stopID = NO;\n  };\n\n  Stream.prototype._add = function (il) {\n    var ta = this._target;\n    if (ta) return ta._add(il);\n    var a = this._ils;\n    a.push(il);\n    if (a.length > 1) return;\n\n    if (this._stopID !== NO) {\n      clearTimeout(this._stopID);\n      this._stopID = NO;\n    } else {\n      var p = this._prod;\n      if (p !== NO) p._start(this);\n    }\n  };\n\n  Stream.prototype._remove = function (il) {\n    var _this = this;\n\n    var ta = this._target;\n    if (ta) return ta._remove(il);\n    var a = this._ils;\n    var i = a.indexOf(il);\n\n    if (i > -1) {\n      a.splice(i, 1);\n\n      if (this._prod !== NO && a.length <= 0) {\n        this._err = NO;\n        this._stopID = setTimeout(function () {\n          return _this._stopNow();\n        });\n      } else if (a.length === 1) {\n        this._pruneCycles();\n      }\n    }\n  }; // If all paths stemming from `this` stream eventually end at `this`\n  // stream, then we remove the single listener of `this` stream, to\n  // force it to end its execution and dispose resources. This method\n  // assumes as a precondition that this._ils has just one listener.\n\n\n  Stream.prototype._pruneCycles = function () {\n    if (this._hasNoSinks(this, [])) this._remove(this._ils[0]);\n  }; // Checks whether *there is no* path starting from `x` that leads to an end\n  // listener (sink) in the stream graph, following edges A->B where B is a\n  // listener of A. This means these paths constitute a cycle somehow. Is given\n  // a trace of all visited nodes so far.\n\n\n  Stream.prototype._hasNoSinks = function (x, trace) {\n    if (trace.indexOf(x) !== -1) return true;else if (x.out === this) return true;else if (x.out && x.out !== NO) return this._hasNoSinks(x.out, trace.concat(x));else if (x._ils) {\n      for (var i = 0, N = x._ils.length; i < N; i++) {\n        if (!this._hasNoSinks(x._ils[i], trace.concat(x))) return false;\n      }\n\n      return true;\n    } else return false;\n  };\n\n  Stream.prototype.ctor = function () {\n    return this instanceof MemoryStream ? MemoryStream : Stream;\n  };\n  /**\n   * Adds a Listener to the Stream.\n   *\n   * @param {Listener} listener\n   */\n\n\n  Stream.prototype.addListener = function (listener) {\n    listener._n = listener.next || noop;\n    listener._e = listener.error || noop;\n    listener._c = listener.complete || noop;\n\n    this._add(listener);\n  };\n  /**\n   * Removes a Listener from the Stream, assuming the Listener was added to it.\n   *\n   * @param {Listener<T>} listener\n   */\n\n\n  Stream.prototype.removeListener = function (listener) {\n    this._remove(listener);\n  };\n  /**\n   * Adds a Listener to the Stream returning a Subscription to remove that\n   * listener.\n   *\n   * @param {Listener} listener\n   * @returns {Subscription}\n   */\n\n\n  Stream.prototype.subscribe = function (listener) {\n    this.addListener(listener);\n    return new StreamSub(this, listener);\n  };\n  /**\n   * Add interop between most.js and RxJS 5\n   *\n   * @returns {Stream}\n   */\n\n\n  Stream.prototype[$$observable] = function () {\n    return this;\n  };\n  /**\n   * Creates a new Stream given a Producer.\n   *\n   * @factory true\n   * @param {Producer} producer An optional Producer that dictates how to\n   * start, generate events, and stop the Stream.\n   * @return {Stream}\n   */\n\n\n  Stream.create = function (producer) {\n    if (producer) {\n      if (typeof producer.start !== 'function' || typeof producer.stop !== 'function') throw new Error('producer requires both start and stop functions');\n      internalizeProducer(producer); // mutates the input\n    }\n\n    return new Stream(producer);\n  };\n  /**\n   * Creates a new MemoryStream given a Producer.\n   *\n   * @factory true\n   * @param {Producer} producer An optional Producer that dictates how to\n   * start, generate events, and stop the Stream.\n   * @return {MemoryStream}\n   */\n\n\n  Stream.createWithMemory = function (producer) {\n    if (producer) internalizeProducer(producer); // mutates the input\n\n    return new MemoryStream(producer);\n  };\n  /**\n   * Creates a Stream that does nothing when started. It never emits any event.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   *          never\n   * -----------------------\n   * ```\n   *\n   * @factory true\n   * @return {Stream}\n   */\n\n\n  Stream.never = function () {\n    return new Stream({\n      _start: noop,\n      _stop: noop\n    });\n  };\n  /**\n   * Creates a Stream that immediately emits the \"complete\" notification when\n   * started, and that's it.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * empty\n   * -|\n   * ```\n   *\n   * @factory true\n   * @return {Stream}\n   */\n\n\n  Stream.empty = function () {\n    return new Stream({\n      _start: function _start(il) {\n        il._c();\n      },\n      _stop: noop\n    });\n  };\n  /**\n   * Creates a Stream that immediately emits an \"error\" notification with the\n   * value you passed as the `error` argument when the stream starts, and that's\n   * it.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * throw(X)\n   * -X\n   * ```\n   *\n   * @factory true\n   * @param error The error event to emit on the created stream.\n   * @return {Stream}\n   */\n\n\n  Stream.throw = function (error) {\n    return new Stream({\n      _start: function _start(il) {\n        il._e(error);\n      },\n      _stop: noop\n    });\n  };\n  /**\n   * Creates a stream from an Array, Promise, or an Observable.\n   *\n   * @factory true\n   * @param {Array|PromiseLike|Observable} input The input to make a stream from.\n   * @return {Stream}\n   */\n\n\n  Stream.from = function (input) {\n    if (typeof input[$$observable] === 'function') return Stream.fromObservable(input);else if (typeof input.then === 'function') return Stream.fromPromise(input);else if (Array.isArray(input)) return Stream.fromArray(input);\n    throw new TypeError(\"Type of input to from() must be an Array, Promise, or Observable\");\n  };\n  /**\n   * Creates a Stream that immediately emits the arguments that you give to\n   * *of*, then completes.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * of(1,2,3)\n   * 123|\n   * ```\n   *\n   * @factory true\n   * @param a The first value you want to emit as an event on the stream.\n   * @param b The second value you want to emit as an event on the stream. One\n   * or more of these values may be given as arguments.\n   * @return {Stream}\n   */\n\n\n  Stream.of = function () {\n    var items = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      items[_i] = arguments[_i];\n    }\n\n    return Stream.fromArray(items);\n  };\n  /**\n   * Converts an array to a stream. The returned stream will emit synchronously\n   * all the items in the array, and then complete.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * fromArray([1,2,3])\n   * 123|\n   * ```\n   *\n   * @factory true\n   * @param {Array} array The array to be converted as a stream.\n   * @return {Stream}\n   */\n\n\n  Stream.fromArray = function (array) {\n    return new Stream(new FromArray(array));\n  };\n  /**\n   * Converts a promise to a stream. The returned stream will emit the resolved\n   * value of the promise, and then complete. However, if the promise is\n   * rejected, the stream will emit the corresponding error.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * fromPromise( ----42 )\n   * -----------------42|\n   * ```\n   *\n   * @factory true\n   * @param {PromiseLike} promise The promise to be converted as a stream.\n   * @return {Stream}\n   */\n\n\n  Stream.fromPromise = function (promise) {\n    return new Stream(new FromPromise(promise));\n  };\n  /**\n   * Converts an Observable into a Stream.\n   *\n   * @factory true\n   * @param {any} observable The observable to be converted as a stream.\n   * @return {Stream}\n   */\n\n\n  Stream.fromObservable = function (obs) {\n    if (obs.endWhen !== undefined) return obs;\n    var o = typeof obs[$$observable] === 'function' ? obs[$$observable]() : obs;\n    return new Stream(new FromObservable(o));\n  };\n  /**\n   * Creates a stream that periodically emits incremental numbers, every\n   * `period` milliseconds.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   *     periodic(1000)\n   * ---0---1---2---3---4---...\n   * ```\n   *\n   * @factory true\n   * @param {number} period The interval in milliseconds to use as a rate of\n   * emission.\n   * @return {Stream}\n   */\n\n\n  Stream.periodic = function (period) {\n    return new Stream(new Periodic(period));\n  };\n\n  Stream.prototype._map = function (project) {\n    return new (this.ctor())(new MapOp(project, this));\n  };\n  /**\n   * Transforms each event from the input Stream through a `project` function,\n   * to get a Stream that emits those transformed events.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --1---3--5-----7------\n   *    map(i => i * 10)\n   * --10--30-50----70-----\n   * ```\n   *\n   * @param {Function} project A function of type `(t: T) => U` that takes event\n   * `t` of type `T` from the input Stream and produces an event of type `U`, to\n   * be emitted on the output Stream.\n   * @return {Stream}\n   */\n\n\n  Stream.prototype.map = function (project) {\n    return this._map(project);\n  };\n  /**\n   * It's like `map`, but transforms each input event to always the same\n   * constant value on the output Stream.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --1---3--5-----7-----\n   *       mapTo(10)\n   * --10--10-10----10----\n   * ```\n   *\n   * @param projectedValue A value to emit on the output Stream whenever the\n   * input Stream emits any value.\n   * @return {Stream}\n   */\n\n\n  Stream.prototype.mapTo = function (projectedValue) {\n    var s = this.map(function () {\n      return projectedValue;\n    });\n    var op = s._prod;\n    op.type = 'mapTo';\n    return s;\n  };\n  /**\n   * Only allows events that pass the test given by the `passes` argument.\n   *\n   * Each event from the input stream is given to the `passes` function. If the\n   * function returns `true`, the event is forwarded to the output stream,\n   * otherwise it is ignored and not forwarded.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --1---2--3-----4-----5---6--7-8--\n   *     filter(i => i % 2 === 0)\n   * ------2--------4---------6----8--\n   * ```\n   *\n   * @param {Function} passes A function of type `(t: T) => boolean` that takes\n   * an event from the input stream and checks if it passes, by returning a\n   * boolean.\n   * @return {Stream}\n   */\n\n\n  Stream.prototype.filter = function (passes) {\n    var p = this._prod;\n    if (p instanceof Filter) return new Stream(new Filter(and(p.f, passes), p.ins));\n    return new Stream(new Filter(passes, this));\n  };\n  /**\n   * Lets the first `amount` many events from the input stream pass to the\n   * output stream, then makes the output stream complete.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --a---b--c----d---e--\n   *    take(3)\n   * --a---b--c|\n   * ```\n   *\n   * @param {number} amount How many events to allow from the input stream\n   * before completing the output stream.\n   * @return {Stream}\n   */\n\n\n  Stream.prototype.take = function (amount) {\n    return new (this.ctor())(new Take(amount, this));\n  };\n  /**\n   * Ignores the first `amount` many events from the input stream, and then\n   * after that starts forwarding events from the input stream to the output\n   * stream.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --a---b--c----d---e--\n   *       drop(3)\n   * --------------d---e--\n   * ```\n   *\n   * @param {number} amount How many events to ignore from the input stream\n   * before forwarding all events from the input stream to the output stream.\n   * @return {Stream}\n   */\n\n\n  Stream.prototype.drop = function (amount) {\n    return new Stream(new Drop(amount, this));\n  };\n  /**\n   * When the input stream completes, the output stream will emit the last event\n   * emitted by the input stream, and then will also complete.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --a---b--c--d----|\n   *       last()\n   * -----------------d|\n   * ```\n   *\n   * @return {Stream}\n   */\n\n\n  Stream.prototype.last = function () {\n    return new Stream(new Last(this));\n  };\n  /**\n   * Prepends the given `initial` value to the sequence of events emitted by the\n   * input stream. The returned stream is a MemoryStream, which means it is\n   * already `remember()`'d.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * ---1---2-----3---\n   *   startWith(0)\n   * 0--1---2-----3---\n   * ```\n   *\n   * @param initial The value or event to prepend.\n   * @return {MemoryStream}\n   */\n\n\n  Stream.prototype.startWith = function (initial) {\n    return new MemoryStream(new StartWith(this, initial));\n  };\n  /**\n   * Uses another stream to determine when to complete the current stream.\n   *\n   * When the given `other` stream emits an event or completes, the output\n   * stream will complete. Before that happens, the output stream will behaves\n   * like the input stream.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * ---1---2-----3--4----5----6---\n   *   endWhen( --------a--b--| )\n   * ---1---2-----3--4--|\n   * ```\n   *\n   * @param other Some other stream that is used to know when should the output\n   * stream of this operator complete.\n   * @return {Stream}\n   */\n\n\n  Stream.prototype.endWhen = function (other) {\n    return new (this.ctor())(new EndWhen(other, this));\n  };\n  /**\n   * \"Folds\" the stream onto itself.\n   *\n   * Combines events from the past throughout\n   * the entire execution of the input stream, allowing you to accumulate them\n   * together. It's essentially like `Array.prototype.reduce`. The returned\n   * stream is a MemoryStream, which means it is already `remember()`'d.\n   *\n   * The output stream starts by emitting the `seed` which you give as argument.\n   * Then, when an event happens on the input stream, it is combined with that\n   * seed value through the `accumulate` function, and the output value is\n   * emitted on the output stream. `fold` remembers that output value as `acc`\n   * (\"accumulator\"), and then when a new input event `t` happens, `acc` will be\n   * combined with that to produce the new `acc` and so forth.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * ------1-----1--2----1----1------\n   *   fold((acc, x) => acc + x, 3)\n   * 3-----4-----5--7----8----9------\n   * ```\n   *\n   * @param {Function} accumulate A function of type `(acc: R, t: T) => R` that\n   * takes the previous accumulated value `acc` and the incoming event from the\n   * input stream and produces the new accumulated value.\n   * @param seed The initial accumulated value, of type `R`.\n   * @return {MemoryStream}\n   */\n\n\n  Stream.prototype.fold = function (accumulate, seed) {\n    return new MemoryStream(new Fold(accumulate, seed, this));\n  };\n  /**\n   * Replaces an error with another stream.\n   *\n   * When (and if) an error happens on the input stream, instead of forwarding\n   * that error to the output stream, *replaceError* will call the `replace`\n   * function which returns the stream that the output stream will replicate.\n   * And, in case that new stream also emits an error, `replace` will be called\n   * again to get another stream to start replicating.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --1---2-----3--4-----X\n   *   replaceError( () => --10--| )\n   * --1---2-----3--4--------10--|\n   * ```\n   *\n   * @param {Function} replace A function of type `(err) => Stream` that takes\n   * the error that occurred on the input stream or on the previous replacement\n   * stream and returns a new stream. The output stream will behave like the\n   * stream that this function returns.\n   * @return {Stream}\n   */\n\n\n  Stream.prototype.replaceError = function (replace) {\n    return new (this.ctor())(new ReplaceError(replace, this));\n  };\n  /**\n   * Flattens a \"stream of streams\", handling only one nested stream at a time\n   * (no concurrency).\n   *\n   * If the input stream is a stream that emits streams, then this operator will\n   * return an output stream which is a flat stream: emits regular events. The\n   * flattening happens without concurrency. It works like this: when the input\n   * stream emits a nested stream, *flatten* will start imitating that nested\n   * one. However, as soon as the next nested stream is emitted on the input\n   * stream, *flatten* will forget the previous nested one it was imitating, and\n   * will start imitating the new nested one.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --+--------+---------------\n   *   \\        \\\n   *    \\       ----1----2---3--\n   *    --a--b----c----d--------\n   *           flatten\n   * -----a--b------1----2---3--\n   * ```\n   *\n   * @return {Stream}\n   */\n\n\n  Stream.prototype.flatten = function () {\n    return new Stream(new Flatten(this));\n  };\n  /**\n   * Passes the input stream to a custom operator, to produce an output stream.\n   *\n   * *compose* is a handy way of using an existing function in a chained style.\n   * Instead of writing `outStream = f(inStream)` you can write\n   * `outStream = inStream.compose(f)`.\n   *\n   * @param {function} operator A function that takes a stream as input and\n   * returns a stream as well.\n   * @return {Stream}\n   */\n\n\n  Stream.prototype.compose = function (operator) {\n    return operator(this);\n  };\n  /**\n   * Returns an output stream that behaves like the input stream, but also\n   * remembers the most recent event that happens on the input stream, so that a\n   * newly added listener will immediately receive that memorised event.\n   *\n   * @return {MemoryStream}\n   */\n\n\n  Stream.prototype.remember = function () {\n    return new MemoryStream(new Remember(this));\n  };\n  /**\n   * Returns an output stream that identically behaves like the input stream,\n   * but also runs a `spy` function for each event, to help you debug your app.\n   *\n   * *debug* takes a `spy` function as argument, and runs that for each event\n   * happening on the input stream. If you don't provide the `spy` argument,\n   * then *debug* will just `console.log` each event. This helps you to\n   * understand the flow of events through some operator chain.\n   *\n   * Please note that if the output stream has no listeners, then it will not\n   * start, which means `spy` will never run because no actual event happens in\n   * that case.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --1----2-----3-----4--\n   *         debug\n   * --1----2-----3-----4--\n   * ```\n   *\n   * @param {function} labelOrSpy A string to use as the label when printing\n   * debug information on the console, or a 'spy' function that takes an event\n   * as argument, and does not need to return anything.\n   * @return {Stream}\n   */\n\n\n  Stream.prototype.debug = function (labelOrSpy) {\n    return new (this.ctor())(new Debug(this, labelOrSpy));\n  };\n  /**\n   * *imitate* changes this current Stream to emit the same events that the\n   * `other` given Stream does. This method returns nothing.\n   *\n   * This method exists to allow one thing: **circular dependency of streams**.\n   * For instance, let's imagine that for some reason you need to create a\n   * circular dependency where stream `first$` depends on stream `second$`\n   * which in turn depends on `first$`:\n   *\n   * <!-- skip-example -->\n   * ```js\n   * import delay from 'xstream/extra/delay'\n   *\n   * var first$ = second$.map(x => x * 10).take(3);\n   * var second$ = first$.map(x => x + 1).startWith(1).compose(delay(100));\n   * ```\n   *\n   * However, that is invalid JavaScript, because `second$` is undefined\n   * on the first line. This is how *imitate* can help solve it:\n   *\n   * ```js\n   * import delay from 'xstream/extra/delay'\n   *\n   * var secondProxy$ = xs.create();\n   * var first$ = secondProxy$.map(x => x * 10).take(3);\n   * var second$ = first$.map(x => x + 1).startWith(1).compose(delay(100));\n   * secondProxy$.imitate(second$);\n   * ```\n   *\n   * We create `secondProxy$` before the others, so it can be used in the\n   * declaration of `first$`. Then, after both `first$` and `second$` are\n   * defined, we hook `secondProxy$` with `second$` with `imitate()` to tell\n   * that they are \"the same\". `imitate` will not trigger the start of any\n   * stream, it just binds `secondProxy$` and `second$` together.\n   *\n   * The following is an example where `imitate()` is important in Cycle.js\n   * applications. A parent component contains some child components. A child\n   * has an action stream which is given to the parent to define its state:\n   *\n   * <!-- skip-example -->\n   * ```js\n   * const childActionProxy$ = xs.create();\n   * const parent = Parent({...sources, childAction$: childActionProxy$});\n   * const childAction$ = parent.state$.map(s => s.child.action$).flatten();\n   * childActionProxy$.imitate(childAction$);\n   * ```\n   *\n   * Note, though, that **`imitate()` does not support MemoryStreams**. If we\n   * would attempt to imitate a MemoryStream in a circular dependency, we would\n   * either get a race condition (where the symptom would be \"nothing happens\")\n   * or an infinite cyclic emission of values. It's useful to think about\n   * MemoryStreams as cells in a spreadsheet. It doesn't make any sense to\n   * define a spreadsheet cell `A1` with a formula that depends on `B1` and\n   * cell `B1` defined with a formula that depends on `A1`.\n   *\n   * If you find yourself wanting to use `imitate()` with a\n   * MemoryStream, you should rework your code around `imitate()` to use a\n   * Stream instead. Look for the stream in the circular dependency that\n   * represents an event stream, and that would be a candidate for creating a\n   * proxy Stream which then imitates the target Stream.\n   *\n   * @param {Stream} target The other stream to imitate on the current one. Must\n   * not be a MemoryStream.\n   */\n\n\n  Stream.prototype.imitate = function (target) {\n    if (target instanceof MemoryStream) throw new Error('A MemoryStream was given to imitate(), but it only ' + 'supports a Stream. Read more about this restriction here: ' + 'https://github.com/staltz/xstream#faq');\n    this._target = target;\n\n    for (var ils = this._ils, N = ils.length, i = 0; i < N; i++) {\n      target._add(ils[i]);\n    }\n\n    this._ils = [];\n  };\n  /**\n   * Forces the Stream to emit the given value to its listeners.\n   *\n   * As the name indicates, if you use this, you are most likely doing something\n   * The Wrong Way. Please try to understand the reactive way before using this\n   * method. Use it only when you know what you are doing.\n   *\n   * @param value The \"next\" value you want to broadcast to all listeners of\n   * this Stream.\n   */\n\n\n  Stream.prototype.shamefullySendNext = function (value) {\n    this._n(value);\n  };\n  /**\n   * Forces the Stream to emit the given error to its listeners.\n   *\n   * As the name indicates, if you use this, you are most likely doing something\n   * The Wrong Way. Please try to understand the reactive way before using this\n   * method. Use it only when you know what you are doing.\n   *\n   * @param {any} error The error you want to broadcast to all the listeners of\n   * this Stream.\n   */\n\n\n  Stream.prototype.shamefullySendError = function (error) {\n    this._e(error);\n  };\n  /**\n   * Forces the Stream to emit the \"completed\" event to its listeners.\n   *\n   * As the name indicates, if you use this, you are most likely doing something\n   * The Wrong Way. Please try to understand the reactive way before using this\n   * method. Use it only when you know what you are doing.\n   */\n\n\n  Stream.prototype.shamefullySendComplete = function () {\n    this._c();\n  };\n  /**\n   * Adds a \"debug\" listener to the stream. There can only be one debug\n   * listener, that's why this is 'setDebugListener'. To remove the debug\n   * listener, just call setDebugListener(null).\n   *\n   * A debug listener is like any other listener. The only difference is that a\n   * debug listener is \"stealthy\": its presence/absence does not trigger the\n   * start/stop of the stream (or the producer inside the stream). This is\n   * useful so you can inspect what is going on without changing the behavior\n   * of the program. If you have an idle stream and you add a normal listener to\n   * it, the stream will start executing. But if you set a debug listener on an\n   * idle stream, it won't start executing (not until the first normal listener\n   * is added).\n   *\n   * As the name indicates, we don't recommend using this method to build app\n   * logic. In fact, in most cases the debug operator works just fine. Only use\n   * this one if you know what you're doing.\n   *\n   * @param {Listener<T>} listener\n   */\n\n\n  Stream.prototype.setDebugListener = function (listener) {\n    if (!listener) {\n      this._d = false;\n      this._dl = NO;\n    } else {\n      this._d = true;\n      listener._n = listener.next || noop;\n      listener._e = listener.error || noop;\n      listener._c = listener.complete || noop;\n      this._dl = listener;\n    }\n  };\n  /**\n   * Blends multiple streams together, emitting events from all of them\n   * concurrently.\n   *\n   * *merge* takes multiple streams as arguments, and creates a stream that\n   * behaves like each of the argument streams, in parallel.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --1----2-----3--------4---\n   * ----a-----b----c---d------\n   *            merge\n   * --1-a--2--b--3-c---d--4---\n   * ```\n   *\n   * @factory true\n   * @param {Stream} stream1 A stream to merge together with other streams.\n   * @param {Stream} stream2 A stream to merge together with other streams. Two\n   * or more streams may be given as arguments.\n   * @return {Stream}\n   */\n\n\n  Stream.merge = function merge() {\n    var streams = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      streams[_i] = arguments[_i];\n    }\n\n    return new Stream(new Merge(streams));\n  };\n  /**\n   * Combines multiple input streams together to return a stream whose events\n   * are arrays that collect the latest events from each input stream.\n   *\n   * *combine* internally remembers the most recent event from each of the input\n   * streams. When any of the input streams emits an event, that event together\n   * with all the other saved events are combined into an array. That array will\n   * be emitted on the output stream. It's essentially a way of joining together\n   * the events from multiple streams.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --1----2-----3--------4---\n   * ----a-----b-----c--d------\n   *          combine\n   * ----1a-2a-2b-3b-3c-3d-4d--\n   * ```\n   *\n   * @factory true\n   * @param {Stream} stream1 A stream to combine together with other streams.\n   * @param {Stream} stream2 A stream to combine together with other streams.\n   * Multiple streams, not just two, may be given as arguments.\n   * @return {Stream}\n   */\n\n\n  Stream.combine = function combine() {\n    var streams = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      streams[_i] = arguments[_i];\n    }\n\n    return new Stream(new Combine(streams));\n  };\n\n  return Stream;\n}();\n\nexports.Stream = Stream;\n\nvar MemoryStream =\n/** @class */\nfunction (_super) {\n  __extends(MemoryStream, _super);\n\n  function MemoryStream(producer) {\n    var _this = _super.call(this, producer) || this;\n\n    _this._has = false;\n    return _this;\n  }\n\n  MemoryStream.prototype._n = function (x) {\n    this._v = x;\n    this._has = true;\n\n    _super.prototype._n.call(this, x);\n  };\n\n  MemoryStream.prototype._add = function (il) {\n    var ta = this._target;\n    if (ta) return ta._add(il);\n    var a = this._ils;\n    a.push(il);\n\n    if (a.length > 1) {\n      if (this._has) il._n(this._v);\n      return;\n    }\n\n    if (this._stopID !== NO) {\n      if (this._has) il._n(this._v);\n      clearTimeout(this._stopID);\n      this._stopID = NO;\n    } else if (this._has) il._n(this._v);else {\n      var p = this._prod;\n      if (p !== NO) p._start(this);\n    }\n  };\n\n  MemoryStream.prototype._stopNow = function () {\n    this._has = false;\n\n    _super.prototype._stopNow.call(this);\n  };\n\n  MemoryStream.prototype._x = function () {\n    this._has = false;\n\n    _super.prototype._x.call(this);\n  };\n\n  MemoryStream.prototype.map = function (project) {\n    return this._map(project);\n  };\n\n  MemoryStream.prototype.mapTo = function (projectedValue) {\n    return _super.prototype.mapTo.call(this, projectedValue);\n  };\n\n  MemoryStream.prototype.take = function (amount) {\n    return _super.prototype.take.call(this, amount);\n  };\n\n  MemoryStream.prototype.endWhen = function (other) {\n    return _super.prototype.endWhen.call(this, other);\n  };\n\n  MemoryStream.prototype.replaceError = function (replace) {\n    return _super.prototype.replaceError.call(this, replace);\n  };\n\n  MemoryStream.prototype.remember = function () {\n    return this;\n  };\n\n  MemoryStream.prototype.debug = function (labelOrSpy) {\n    return _super.prototype.debug.call(this, labelOrSpy);\n  };\n\n  return MemoryStream;\n}(Stream);\n\nexports.MemoryStream = MemoryStream;\nvar xs = Stream;\nexports.default = xs;","map":null,"metadata":{},"sourceType":"script"}