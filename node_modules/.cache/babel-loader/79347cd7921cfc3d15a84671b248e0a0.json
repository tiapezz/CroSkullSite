{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"F:\\\\Mattia\\\\Visual studio\\\\ProjectCroSkull\\\\croskull-nft-marketplace\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\n\nvar _slicedToArray = require(\"F:\\\\Mattia\\\\Visual studio\\\\ProjectCroSkull\\\\croskull-nft-marketplace\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.encodeBech32Pubkey = exports.encodeAminoPubkey = exports.decodeBech32Pubkey = exports.decodeAminoPubkey = exports.encodeSecp256k1Pubkey = void 0;\n\nvar encoding_1 = require(\"@cosmjs/encoding\");\n\nvar math_1 = require(\"@cosmjs/math\");\n\nvar utils_1 = require(\"@cosmjs/utils\");\n\nvar pubkeys_1 = require(\"./pubkeys\");\n\nfunction encodeSecp256k1Pubkey(pubkey) {\n  if (pubkey.length !== 33 || pubkey[0] !== 0x02 && pubkey[0] !== 0x03) {\n    throw new Error(\"Public key must be compressed secp256k1, i.e. 33 bytes starting with 0x02 or 0x03\");\n  }\n\n  return {\n    type: pubkeys_1.pubkeyType.secp256k1,\n    value: encoding_1.toBase64(pubkey)\n  };\n}\n\nexports.encodeSecp256k1Pubkey = encodeSecp256k1Pubkey; // As discussed in https://github.com/binance-chain/javascript-sdk/issues/163\n// Prefixes listed here: https://github.com/tendermint/tendermint/blob/d419fffe18531317c28c29a292ad7d253f6cafdf/docs/spec/blockchain/encoding.md#public-key-cryptography\n// Last bytes is varint-encoded length prefix\n\nvar pubkeyAminoPrefixSecp256k1 = encoding_1.fromHex(\"eb5ae987\" + \"21\"\n/* fixed length */\n);\nvar pubkeyAminoPrefixEd25519 = encoding_1.fromHex(\"1624de64\" + \"20\"\n/* fixed length */\n);\nvar pubkeyAminoPrefixSr25519 = encoding_1.fromHex(\"0dfb1005\" + \"20\"\n/* fixed length */\n);\n/** See https://github.com/tendermint/tendermint/commit/38b401657e4ad7a7eeb3c30a3cbf512037df3740 */\n\nvar pubkeyAminoPrefixMultisigThreshold = encoding_1.fromHex(\"22c1f7e2\"\n/* variable length not included */\n);\n/**\n * Decodes a pubkey in the Amino binary format to a type/value object.\n */\n\nfunction decodeAminoPubkey(data) {\n  if (utils_1.arrayContentStartsWith(data, pubkeyAminoPrefixSecp256k1)) {\n    var rest = data.slice(pubkeyAminoPrefixSecp256k1.length);\n\n    if (rest.length !== 33) {\n      throw new Error(\"Invalid rest data length. Expected 33 bytes (compressed secp256k1 pubkey).\");\n    }\n\n    return {\n      type: pubkeys_1.pubkeyType.secp256k1,\n      value: encoding_1.toBase64(rest)\n    };\n  } else if (utils_1.arrayContentStartsWith(data, pubkeyAminoPrefixEd25519)) {\n    var _rest = data.slice(pubkeyAminoPrefixEd25519.length);\n\n    if (_rest.length !== 32) {\n      throw new Error(\"Invalid rest data length. Expected 32 bytes (Ed25519 pubkey).\");\n    }\n\n    return {\n      type: pubkeys_1.pubkeyType.ed25519,\n      value: encoding_1.toBase64(_rest)\n    };\n  } else if (utils_1.arrayContentStartsWith(data, pubkeyAminoPrefixSr25519)) {\n    var _rest2 = data.slice(pubkeyAminoPrefixSr25519.length);\n\n    if (_rest2.length !== 32) {\n      throw new Error(\"Invalid rest data length. Expected 32 bytes (Sr25519 pubkey).\");\n    }\n\n    return {\n      type: pubkeys_1.pubkeyType.sr25519,\n      value: encoding_1.toBase64(_rest2)\n    };\n  } else if (utils_1.arrayContentStartsWith(data, pubkeyAminoPrefixMultisigThreshold)) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return decodeMultisigPubkey(data);\n  } else {\n    throw new Error(\"Unsupported public key type. Amino data starts with: \" + encoding_1.toHex(data.slice(0, 5)));\n  }\n}\n\nexports.decodeAminoPubkey = decodeAminoPubkey;\n/**\n * Decodes a bech32 pubkey to Amino binary, which is then decoded to a type/value object.\n * The bech32 prefix is ignored and discareded.\n *\n * @param bechEncoded the bech32 encoded pubkey\n */\n\nfunction decodeBech32Pubkey(bechEncoded) {\n  var _encoding_1$Bech32$de = encoding_1.Bech32.decode(bechEncoded),\n      data = _encoding_1$Bech32$de.data;\n\n  return decodeAminoPubkey(data);\n}\n\nexports.decodeBech32Pubkey = decodeBech32Pubkey;\n/**\n * Uvarint decoder for Amino.\n * @see https://github.com/tendermint/go-amino/blob/8e779b71f40d175/decoder.go#L64-76\n * @returns varint as number, and bytes count occupied by varaint\n */\n\nfunction decodeUvarint(reader) {\n  if (reader.length < 1) {\n    throw new Error(\"Can't decode varint. EOF\");\n  }\n\n  if (reader[0] > 127) {\n    throw new Error(\"Decoding numbers > 127 is not supported here. Please tell those lazy CosmJS maintainers to port the binary.Varint implementation from the Go standard library and write some tests.\");\n  }\n\n  return [reader[0], 1];\n}\n/**\n * Decodes a multisig pubkey to type object.\n * Pubkey structure [ prefix + const + threshold + loop:(const + pubkeyLength + pubkey            ) ]\n *                  [   4b   + 1b    +  varint   + loop:(1b    +    varint    + pubkeyLength bytes) ]\n * @param data encoded pubkey\n */\n\n\nfunction decodeMultisigPubkey(data) {\n  var reader = Array.from(data); // remove multisig amino prefix;\n\n  var prefixFromReader = reader.splice(0, pubkeyAminoPrefixMultisigThreshold.length);\n\n  if (!utils_1.arrayContentStartsWith(prefixFromReader, pubkeyAminoPrefixMultisigThreshold)) {\n    throw new Error(\"Invalid multisig prefix.\");\n  } // remove 0x08 threshold prefix;\n\n\n  if (reader.shift() != 0x08) {\n    throw new Error(\"Invalid multisig data. Expecting 0x08 prefix before threshold.\");\n  } // read threshold\n\n\n  var _decodeUvarint = decodeUvarint(reader),\n      _decodeUvarint2 = _slicedToArray(_decodeUvarint, 2),\n      threshold = _decodeUvarint2[0],\n      thresholdBytesLength = _decodeUvarint2[1];\n\n  reader.splice(0, thresholdBytesLength); // read participants pubkeys\n\n  var pubkeys = [];\n\n  while (reader.length > 0) {\n    // remove 0x12 threshold prefix;\n    if (reader.shift() != 0x12) {\n      throw new Error(\"Invalid multisig data. Expecting 0x12 prefix before participant pubkey length.\");\n    } // read pubkey length\n\n\n    var _decodeUvarint3 = decodeUvarint(reader),\n        _decodeUvarint4 = _slicedToArray(_decodeUvarint3, 2),\n        pubkeyLength = _decodeUvarint4[0],\n        pubkeyLengthBytesSize = _decodeUvarint4[1];\n\n    reader.splice(0, pubkeyLengthBytesSize); // verify that we can read pubkey\n\n    if (reader.length < pubkeyLength) {\n      throw new Error(\"Invalid multisig data length.\");\n    } // read and decode participant pubkey\n\n\n    var encodedPubkey = reader.splice(0, pubkeyLength);\n    var pubkey = decodeAminoPubkey(Uint8Array.from(encodedPubkey));\n    pubkeys.push(pubkey);\n  }\n\n  return {\n    type: pubkeys_1.pubkeyType.multisigThreshold,\n    value: {\n      threshold: threshold.toString(),\n      pubkeys: pubkeys\n    }\n  };\n}\n/**\n * Uvarint encoder for Amino. This is the same encoding as `binary.PutUvarint` from the Go\n * standard library.\n *\n * @see https://github.com/tendermint/go-amino/blob/8e779b71f40d175/encoder.go#L77-L85\n */\n\n\nfunction encodeUvarint(value) {\n  var checked = math_1.Uint53.fromString(value.toString()).toNumber();\n\n  if (checked > 127) {\n    throw new Error(\"Encoding numbers > 127 is not supported here. Please tell those lazy CosmJS maintainers to port the binary.PutUvarint implementation from the Go standard library and write some tests.\");\n  }\n\n  return [checked];\n}\n/**\n * Encodes a public key to binary Amino.\n */\n\n\nfunction encodeAminoPubkey(pubkey) {\n  if (pubkeys_1.isMultisigThresholdPubkey(pubkey)) {\n    var out = Array.from(pubkeyAminoPrefixMultisigThreshold);\n    out.push(0x08); // TODO: What is this?\n\n    out.push.apply(out, _toConsumableArray(encodeUvarint(pubkey.value.threshold)));\n\n    var _iterator = _createForOfIteratorHelper(pubkey.value.pubkeys.map(function (p) {\n      return encodeAminoPubkey(p);\n    })),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var pubkeyData = _step.value;\n        out.push(0x12); // TODO: What is this?\n\n        out.push.apply(out, _toConsumableArray(encodeUvarint(pubkeyData.length)));\n        out.push.apply(out, _toConsumableArray(pubkeyData));\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return new Uint8Array(out);\n  } else if (pubkeys_1.isEd25519Pubkey(pubkey)) {\n    return new Uint8Array([].concat(_toConsumableArray(pubkeyAminoPrefixEd25519), _toConsumableArray(encoding_1.fromBase64(pubkey.value))));\n  } else if (pubkeys_1.isSecp256k1Pubkey(pubkey)) {\n    return new Uint8Array([].concat(_toConsumableArray(pubkeyAminoPrefixSecp256k1), _toConsumableArray(encoding_1.fromBase64(pubkey.value))));\n  } else {\n    throw new Error(\"Unsupported pubkey type\");\n  }\n}\n\nexports.encodeAminoPubkey = encodeAminoPubkey;\n/**\n * Encodes a public key to binary Amino and then to bech32.\n *\n * @param pubkey the public key to encode\n * @param prefix the bech32 prefix (human readable part)\n */\n\nfunction encodeBech32Pubkey(pubkey, prefix) {\n  return encoding_1.Bech32.encode(prefix, encodeAminoPubkey(pubkey));\n}\n\nexports.encodeBech32Pubkey = encodeBech32Pubkey;","map":null,"metadata":{},"sourceType":"script"}