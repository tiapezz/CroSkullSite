{"ast":null,"code":"import _regeneratorRuntime from \"F:\\\\Mattia\\\\Visual studio\\\\AppCroskull\\\\croskull-nft-marketplace\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _asyncToGenerator from \"F:\\\\Mattia\\\\Visual studio\\\\AppCroskull\\\\croskull-nft-marketplace\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport { ethers } from \"ethers\";\nimport store from \"../store\";\nimport { sendNotification, getSkullsData } from \"../data/dataActions\";\n\nvar fetchRaffleRequest = function fetchRaffleRequest() {\n  return {\n    type: \"FETCH_RAFFLE_REQUEST\"\n  };\n};\n\nvar fetchRaffleSuccess = function fetchRaffleSuccess(payload) {\n  return {\n    type: \"FETCH_RAFFLE_SUCCESS\",\n    payload: payload\n  };\n};\n\nexport var loadRaffleData = function loadRaffleData() {\n  return /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(dispatch) {\n      var _store$getState$block, accountAddress, croRaffle, croSkullsGrave, raffleCount, raffles, i, raffle, winners, playersCount, ipfsHash, hashMetadata, _yield$hashMetadata$j, type, title, winnersCount, maxParticipants, cost, collectionName, collectionAddress, startTimestamp, endTimestamp, description, isManager, owner, allowance;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              dispatch(fetchRaffleRequest());\n              _store$getState$block = store.getState().blockchain, accountAddress = _store$getState$block.accountAddress, croRaffle = _store$getState$block.croRaffle, croSkullsGrave = _store$getState$block.croSkullsGrave;\n\n              if (croRaffle) {\n                _context.next = 4;\n                break;\n              }\n\n              return _context.abrupt(\"return\");\n\n            case 4:\n              _context.next = 6;\n              return croRaffle.raffleCounter();\n\n            case 6:\n              raffleCount = _context.sent;\n              raffles = [];\n              _context.next = 10;\n              return raffleCount.toString();\n\n            case 10:\n              raffleCount = _context.sent;\n              console.log(raffleCount);\n\n              if (!raffleCount) {\n                _context.next = 46;\n                break;\n              }\n\n              i = 0;\n\n            case 14:\n              if (!(i < raffleCount)) {\n                _context.next = 46;\n                break;\n              }\n\n              _context.next = 17;\n              return croRaffle.getRaffle(i);\n\n            case 17:\n              raffle = _context.sent;\n              _context.next = 20;\n              return croRaffle.getWinners(i);\n\n            case 20:\n              winners = _context.sent;\n              _context.next = 23;\n              return raffle.playersCount.toString();\n\n            case 23:\n              playersCount = _context.sent;\n              ipfsHash = raffle.ipfsHash.replace('ipfs://', 'https://ipfs.infura.io/ipfs/');\n              _context.next = 27;\n              return fetch(ipfsHash);\n\n            case 27:\n              hashMetadata = _context.sent;\n              console.log(raffle.cost.toString());\n              _context.next = 31;\n              return hashMetadata.json();\n\n            case 31:\n              _yield$hashMetadata$j = _context.sent;\n              type = _yield$hashMetadata$j.type;\n              title = _yield$hashMetadata$j.title;\n              winnersCount = _yield$hashMetadata$j.winnersCount;\n              maxParticipants = _yield$hashMetadata$j.maxParticipants;\n              cost = _yield$hashMetadata$j.cost;\n              collectionName = _yield$hashMetadata$j.collectionName;\n              collectionAddress = _yield$hashMetadata$j.collectionAddress;\n              startTimestamp = _yield$hashMetadata$j.startTimestamp;\n              endTimestamp = _yield$hashMetadata$j.endTimestamp;\n              description = _yield$hashMetadata$j.description;\n              raffles.push({\n                type: type,\n                title: title,\n                id: i,\n                winnersCount: winnersCount,\n                maxParticipants: maxParticipants,\n                cost: cost,\n                collectionName: collectionName,\n                collectionAddress: collectionAddress,\n                startTimestamp: startTimestamp,\n                endTimestamp: endTimestamp,\n                description: description,\n                winners: winners,\n                participants: playersCount\n              });\n\n            case 43:\n              i++;\n              _context.next = 14;\n              break;\n\n            case 46:\n              _context.next = 48;\n              return croRaffle.managers(accountAddress);\n\n            case 48:\n              isManager = _context.sent;\n              _context.next = 51;\n              return croRaffle.owner();\n\n            case 51:\n              owner = _context.sent;\n              if (ethers.utils.getAddress(owner) == ethers.utils.getAddress(accountAddress)) isManager = true;\n              _context.next = 55;\n              return croSkullsGrave.allowance(accountAddress, croRaffle.address);\n\n            case 55:\n              allowance = _context.sent;\n              allowance = allowance.toString();\n              dispatch(fetchRaffleSuccess({\n                raffleCount: raffleCount,\n                init: true,\n                raffles: raffles,\n                allowance: allowance,\n                isManager: isManager\n              }));\n\n            case 58:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n};\n/*\r\nexport const purchaseItem = ( { _listingId, _cost, _skullId } ) => {\r\n    return async (dispatch) => {\r\n        let { ebisusMarketplace } = store.getState().blockchain\r\n        if( ! ebisusMarketplace || ! _listingId) return\r\n        let purchaseTx = ebisusMarketplace.makePurchase(_listingId, {\r\n            value: _cost\r\n        })\r\n        await purchaseTx.then(\r\n            async (tx) => {\r\n                dispatch(sendNotification({\r\n                    title: `Transaction Sent`,\r\n                    message: 'Waiting for confirmation',\r\n                    tx,\r\n                    type: \"info\"\r\n                }))\r\n                await tx.wait(2)\r\n                dispatch(sendNotification({\r\n                    title: `Success`,\r\n                    message: `Item #${_skullId} purchased!`,\r\n                    tx,\r\n                    type: \"success\"\r\n                }))\r\n                dispatch(getSkullsData())\r\n            }\r\n        )\r\n    }\r\n}*/","map":{"version":3,"sources":["F:/Mattia/Visual studio/AppCroskull/croskull-nft-marketplace/src/redux/raffle/raffleActions.js"],"names":["ethers","store","sendNotification","getSkullsData","fetchRaffleRequest","type","fetchRaffleSuccess","payload","loadRaffleData","dispatch","getState","blockchain","accountAddress","croRaffle","croSkullsGrave","raffleCounter","raffleCount","raffles","toString","console","log","i","getRaffle","raffle","getWinners","winners","playersCount","ipfsHash","replace","fetch","hashMetadata","cost","json","title","winnersCount","maxParticipants","collectionName","collectionAddress","startTimestamp","endTimestamp","description","push","id","participants","managers","isManager","owner","utils","getAddress","allowance","address","init"],"mappings":"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","sourcesContent":["import { ethers } from \"ethers\";\r\nimport store from \"../store\";\r\nimport { sendNotification, getSkullsData } from \"../data/dataActions\";\r\n\r\nconst fetchRaffleRequest = () => {\r\n  return {\r\n    type: \"FETCH_RAFFLE_REQUEST\",\r\n  };\r\n};\r\n\r\nconst fetchRaffleSuccess = (payload) => {\r\n    return {\r\n      type: \"FETCH_RAFFLE_SUCCESS\",\r\n      payload: payload\r\n    }\r\n}\r\n\r\nexport const loadRaffleData = () => {\r\n    return async (dispatch) => {\r\n        dispatch(fetchRaffleRequest())\r\n        let { accountAddress, croRaffle, croSkullsGrave } = store.getState().blockchain\r\n        if( ! croRaffle ) return\r\n        let raffleCount = await croRaffle.raffleCounter()\r\n        let raffles = []\r\n        \r\n        raffleCount = await raffleCount.toString()\r\n        console.log( raffleCount )\r\n        if( raffleCount ) {\r\n            for( let i = 0; i < raffleCount; i++){\r\n                let raffle = await croRaffle.getRaffle(i)\r\n                let winners = await croRaffle.getWinners(i)\r\n                let playersCount = await raffle.playersCount.toString()\r\n\r\n                let ipfsHash = raffle.ipfsHash.replace('ipfs://', 'https://ipfs.infura.io/ipfs/')\r\n                let hashMetadata = await fetch( ipfsHash );\r\n                console.log( raffle.cost.toString() )\r\n                let { type, title, winnersCount, maxParticipants, cost, collectionName, collectionAddress, startTimestamp, endTimestamp, description } = await hashMetadata.json();\r\n                raffles.push({\r\n                    type, \r\n                    title,\r\n                    id: i,\r\n                    winnersCount,\r\n                    maxParticipants, \r\n                    cost, \r\n                    collectionName, \r\n                    collectionAddress,\r\n                    startTimestamp,\r\n                    endTimestamp,\r\n                    description,\r\n                    winners,\r\n                    participants: playersCount\r\n                })\r\n            }\r\n        }\r\n        let isManager = await croRaffle.managers(accountAddress)\r\n        let owner = await croRaffle.owner()\r\n        if(  ethers.utils.getAddress(owner) == ethers.utils.getAddress( accountAddress ) ) \r\n            isManager = true\r\n\r\n        let allowance = await croSkullsGrave.allowance( accountAddress, croRaffle.address )\r\n        allowance = allowance.toString()\r\n\r\n        dispatch(fetchRaffleSuccess( {\r\n            raffleCount,\r\n            init: true,\r\n            raffles,\r\n            allowance,\r\n            isManager\r\n        } ))\r\n    }\r\n}\r\n/*\r\nexport const purchaseItem = ( { _listingId, _cost, _skullId } ) => {\r\n    return async (dispatch) => {\r\n        let { ebisusMarketplace } = store.getState().blockchain\r\n        if( ! ebisusMarketplace || ! _listingId) return\r\n        let purchaseTx = ebisusMarketplace.makePurchase(_listingId, {\r\n            value: _cost\r\n        })\r\n        await purchaseTx.then(\r\n            async (tx) => {\r\n                dispatch(sendNotification({\r\n                    title: `Transaction Sent`,\r\n                    message: 'Waiting for confirmation',\r\n                    tx,\r\n                    type: \"info\"\r\n                }))\r\n                await tx.wait(2)\r\n                dispatch(sendNotification({\r\n                    title: `Success`,\r\n                    message: `Item #${_skullId} purchased!`,\r\n                    tx,\r\n                    type: \"success\"\r\n                }))\r\n                dispatch(getSkullsData())\r\n            }\r\n        )\r\n    }\r\n}*/"]},"metadata":{},"sourceType":"module"}