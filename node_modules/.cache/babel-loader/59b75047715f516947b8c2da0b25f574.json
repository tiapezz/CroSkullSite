{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"F:\\\\Mattia\\\\Visual studio\\\\ProjectCroSkull\\\\croskull-nft-marketplace\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"F:\\\\Mattia\\\\Visual studio\\\\ProjectCroSkull\\\\croskull-nft-marketplace\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MsgClientImpl = exports.MsgConnectionOpenConfirmResponse = exports.MsgConnectionOpenConfirm = exports.MsgConnectionOpenAckResponse = exports.MsgConnectionOpenAck = exports.MsgConnectionOpenTryResponse = exports.MsgConnectionOpenTry = exports.MsgConnectionOpenInitResponse = exports.MsgConnectionOpenInit = exports.protobufPackage = void 0;\n/* eslint-disable */\n\nvar long_1 = __importDefault(require(\"long\"));\n\nvar minimal_1 = __importDefault(require(\"protobufjs/minimal\"));\n\nvar connection_1 = require(\"../../../../ibc/core/connection/v1/connection\");\n\nvar any_1 = require(\"../../../../google/protobuf/any\");\n\nvar client_1 = require(\"../../../../ibc/core/client/v1/client\");\n\nexports.protobufPackage = \"ibc.core.connection.v1\";\nvar baseMsgConnectionOpenInit = {\n  clientId: \"\",\n  delayPeriod: long_1.default.UZERO,\n  signer: \"\"\n};\nexports.MsgConnectionOpenInit = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n\n    if (message.clientId !== \"\") {\n      writer.uint32(10).string(message.clientId);\n    }\n\n    if (message.counterparty !== undefined) {\n      connection_1.Counterparty.encode(message.counterparty, writer.uint32(18).fork()).ldelim();\n    }\n\n    if (message.version !== undefined) {\n      connection_1.Version.encode(message.version, writer.uint32(26).fork()).ldelim();\n    }\n\n    if (!message.delayPeriod.isZero()) {\n      writer.uint32(32).uint64(message.delayPeriod);\n    }\n\n    if (message.signer !== \"\") {\n      writer.uint32(42).string(message.signer);\n    }\n\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = Object.assign({}, baseMsgConnectionOpenInit);\n\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.clientId = reader.string();\n          break;\n\n        case 2:\n          message.counterparty = connection_1.Counterparty.decode(reader, reader.uint32());\n          break;\n\n        case 3:\n          message.version = connection_1.Version.decode(reader, reader.uint32());\n          break;\n\n        case 4:\n          message.delayPeriod = reader.uint64();\n          break;\n\n        case 5:\n          message.signer = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n  fromJSON: function fromJSON(object) {\n    var message = Object.assign({}, baseMsgConnectionOpenInit);\n\n    if (object.clientId !== undefined && object.clientId !== null) {\n      message.clientId = String(object.clientId);\n    } else {\n      message.clientId = \"\";\n    }\n\n    if (object.counterparty !== undefined && object.counterparty !== null) {\n      message.counterparty = connection_1.Counterparty.fromJSON(object.counterparty);\n    } else {\n      message.counterparty = undefined;\n    }\n\n    if (object.version !== undefined && object.version !== null) {\n      message.version = connection_1.Version.fromJSON(object.version);\n    } else {\n      message.version = undefined;\n    }\n\n    if (object.delayPeriod !== undefined && object.delayPeriod !== null) {\n      message.delayPeriod = long_1.default.fromString(object.delayPeriod);\n    } else {\n      message.delayPeriod = long_1.default.UZERO;\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = String(object.signer);\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  },\n  toJSON: function toJSON(message) {\n    var obj = {};\n    message.clientId !== undefined && (obj.clientId = message.clientId);\n    message.counterparty !== undefined && (obj.counterparty = message.counterparty ? connection_1.Counterparty.toJSON(message.counterparty) : undefined);\n    message.version !== undefined && (obj.version = message.version ? connection_1.Version.toJSON(message.version) : undefined);\n    message.delayPeriod !== undefined && (obj.delayPeriod = (message.delayPeriod || long_1.default.UZERO).toString());\n    message.signer !== undefined && (obj.signer = message.signer);\n    return obj;\n  },\n  fromPartial: function fromPartial(object) {\n    var _a, _b;\n\n    var message = Object.assign({}, baseMsgConnectionOpenInit);\n    message.clientId = (_a = object.clientId) !== null && _a !== void 0 ? _a : \"\";\n\n    if (object.counterparty !== undefined && object.counterparty !== null) {\n      message.counterparty = connection_1.Counterparty.fromPartial(object.counterparty);\n    } else {\n      message.counterparty = undefined;\n    }\n\n    if (object.version !== undefined && object.version !== null) {\n      message.version = connection_1.Version.fromPartial(object.version);\n    } else {\n      message.version = undefined;\n    }\n\n    if (object.delayPeriod !== undefined && object.delayPeriod !== null) {\n      message.delayPeriod = object.delayPeriod;\n    } else {\n      message.delayPeriod = long_1.default.UZERO;\n    }\n\n    message.signer = (_b = object.signer) !== null && _b !== void 0 ? _b : \"\";\n    return message;\n  }\n};\nvar baseMsgConnectionOpenInitResponse = {};\nexports.MsgConnectionOpenInitResponse = {\n  encode: function encode(_) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = Object.assign({}, baseMsgConnectionOpenInitResponse);\n\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n  fromJSON: function fromJSON(_) {\n    var message = Object.assign({}, baseMsgConnectionOpenInitResponse);\n    return message;\n  },\n  toJSON: function toJSON(_) {\n    var obj = {};\n    return obj;\n  },\n  fromPartial: function fromPartial(_) {\n    var message = Object.assign({}, baseMsgConnectionOpenInitResponse);\n    return message;\n  }\n};\nvar baseMsgConnectionOpenTry = {\n  clientId: \"\",\n  previousConnectionId: \"\",\n  delayPeriod: long_1.default.UZERO,\n  signer: \"\"\n};\nexports.MsgConnectionOpenTry = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n\n    if (message.clientId !== \"\") {\n      writer.uint32(10).string(message.clientId);\n    }\n\n    if (message.previousConnectionId !== \"\") {\n      writer.uint32(18).string(message.previousConnectionId);\n    }\n\n    if (message.clientState !== undefined) {\n      any_1.Any.encode(message.clientState, writer.uint32(26).fork()).ldelim();\n    }\n\n    if (message.counterparty !== undefined) {\n      connection_1.Counterparty.encode(message.counterparty, writer.uint32(34).fork()).ldelim();\n    }\n\n    if (!message.delayPeriod.isZero()) {\n      writer.uint32(40).uint64(message.delayPeriod);\n    }\n\n    var _iterator = _createForOfIteratorHelper(message.counterpartyVersions),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var v = _step.value;\n        connection_1.Version.encode(v, writer.uint32(50).fork()).ldelim();\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    if (message.proofHeight !== undefined) {\n      client_1.Height.encode(message.proofHeight, writer.uint32(58).fork()).ldelim();\n    }\n\n    if (message.proofInit.length !== 0) {\n      writer.uint32(66).bytes(message.proofInit);\n    }\n\n    if (message.proofClient.length !== 0) {\n      writer.uint32(74).bytes(message.proofClient);\n    }\n\n    if (message.proofConsensus.length !== 0) {\n      writer.uint32(82).bytes(message.proofConsensus);\n    }\n\n    if (message.consensusHeight !== undefined) {\n      client_1.Height.encode(message.consensusHeight, writer.uint32(90).fork()).ldelim();\n    }\n\n    if (message.signer !== \"\") {\n      writer.uint32(98).string(message.signer);\n    }\n\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = Object.assign({}, baseMsgConnectionOpenTry);\n    message.counterpartyVersions = [];\n    message.proofInit = new Uint8Array();\n    message.proofClient = new Uint8Array();\n    message.proofConsensus = new Uint8Array();\n\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.clientId = reader.string();\n          break;\n\n        case 2:\n          message.previousConnectionId = reader.string();\n          break;\n\n        case 3:\n          message.clientState = any_1.Any.decode(reader, reader.uint32());\n          break;\n\n        case 4:\n          message.counterparty = connection_1.Counterparty.decode(reader, reader.uint32());\n          break;\n\n        case 5:\n          message.delayPeriod = reader.uint64();\n          break;\n\n        case 6:\n          message.counterpartyVersions.push(connection_1.Version.decode(reader, reader.uint32()));\n          break;\n\n        case 7:\n          message.proofHeight = client_1.Height.decode(reader, reader.uint32());\n          break;\n\n        case 8:\n          message.proofInit = reader.bytes();\n          break;\n\n        case 9:\n          message.proofClient = reader.bytes();\n          break;\n\n        case 10:\n          message.proofConsensus = reader.bytes();\n          break;\n\n        case 11:\n          message.consensusHeight = client_1.Height.decode(reader, reader.uint32());\n          break;\n\n        case 12:\n          message.signer = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n  fromJSON: function fromJSON(object) {\n    var message = Object.assign({}, baseMsgConnectionOpenTry);\n    message.counterpartyVersions = [];\n    message.proofInit = new Uint8Array();\n    message.proofClient = new Uint8Array();\n    message.proofConsensus = new Uint8Array();\n\n    if (object.clientId !== undefined && object.clientId !== null) {\n      message.clientId = String(object.clientId);\n    } else {\n      message.clientId = \"\";\n    }\n\n    if (object.previousConnectionId !== undefined && object.previousConnectionId !== null) {\n      message.previousConnectionId = String(object.previousConnectionId);\n    } else {\n      message.previousConnectionId = \"\";\n    }\n\n    if (object.clientState !== undefined && object.clientState !== null) {\n      message.clientState = any_1.Any.fromJSON(object.clientState);\n    } else {\n      message.clientState = undefined;\n    }\n\n    if (object.counterparty !== undefined && object.counterparty !== null) {\n      message.counterparty = connection_1.Counterparty.fromJSON(object.counterparty);\n    } else {\n      message.counterparty = undefined;\n    }\n\n    if (object.delayPeriod !== undefined && object.delayPeriod !== null) {\n      message.delayPeriod = long_1.default.fromString(object.delayPeriod);\n    } else {\n      message.delayPeriod = long_1.default.UZERO;\n    }\n\n    if (object.counterpartyVersions !== undefined && object.counterpartyVersions !== null) {\n      var _iterator2 = _createForOfIteratorHelper(object.counterpartyVersions),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var e = _step2.value;\n          message.counterpartyVersions.push(connection_1.Version.fromJSON(e));\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromJSON(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n\n    if (object.proofInit !== undefined && object.proofInit !== null) {\n      message.proofInit = bytesFromBase64(object.proofInit);\n    }\n\n    if (object.proofClient !== undefined && object.proofClient !== null) {\n      message.proofClient = bytesFromBase64(object.proofClient);\n    }\n\n    if (object.proofConsensus !== undefined && object.proofConsensus !== null) {\n      message.proofConsensus = bytesFromBase64(object.proofConsensus);\n    }\n\n    if (object.consensusHeight !== undefined && object.consensusHeight !== null) {\n      message.consensusHeight = client_1.Height.fromJSON(object.consensusHeight);\n    } else {\n      message.consensusHeight = undefined;\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = String(object.signer);\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  },\n  toJSON: function toJSON(message) {\n    var obj = {};\n    message.clientId !== undefined && (obj.clientId = message.clientId);\n    message.previousConnectionId !== undefined && (obj.previousConnectionId = message.previousConnectionId);\n    message.clientState !== undefined && (obj.clientState = message.clientState ? any_1.Any.toJSON(message.clientState) : undefined);\n    message.counterparty !== undefined && (obj.counterparty = message.counterparty ? connection_1.Counterparty.toJSON(message.counterparty) : undefined);\n    message.delayPeriod !== undefined && (obj.delayPeriod = (message.delayPeriod || long_1.default.UZERO).toString());\n\n    if (message.counterpartyVersions) {\n      obj.counterpartyVersions = message.counterpartyVersions.map(function (e) {\n        return e ? connection_1.Version.toJSON(e) : undefined;\n      });\n    } else {\n      obj.counterpartyVersions = [];\n    }\n\n    message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);\n    message.proofInit !== undefined && (obj.proofInit = base64FromBytes(message.proofInit !== undefined ? message.proofInit : new Uint8Array()));\n    message.proofClient !== undefined && (obj.proofClient = base64FromBytes(message.proofClient !== undefined ? message.proofClient : new Uint8Array()));\n    message.proofConsensus !== undefined && (obj.proofConsensus = base64FromBytes(message.proofConsensus !== undefined ? message.proofConsensus : new Uint8Array()));\n    message.consensusHeight !== undefined && (obj.consensusHeight = message.consensusHeight ? client_1.Height.toJSON(message.consensusHeight) : undefined);\n    message.signer !== undefined && (obj.signer = message.signer);\n    return obj;\n  },\n  fromPartial: function fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f;\n\n    var message = Object.assign({}, baseMsgConnectionOpenTry);\n    message.clientId = (_a = object.clientId) !== null && _a !== void 0 ? _a : \"\";\n    message.previousConnectionId = (_b = object.previousConnectionId) !== null && _b !== void 0 ? _b : \"\";\n\n    if (object.clientState !== undefined && object.clientState !== null) {\n      message.clientState = any_1.Any.fromPartial(object.clientState);\n    } else {\n      message.clientState = undefined;\n    }\n\n    if (object.counterparty !== undefined && object.counterparty !== null) {\n      message.counterparty = connection_1.Counterparty.fromPartial(object.counterparty);\n    } else {\n      message.counterparty = undefined;\n    }\n\n    if (object.delayPeriod !== undefined && object.delayPeriod !== null) {\n      message.delayPeriod = object.delayPeriod;\n    } else {\n      message.delayPeriod = long_1.default.UZERO;\n    }\n\n    message.counterpartyVersions = [];\n\n    if (object.counterpartyVersions !== undefined && object.counterpartyVersions !== null) {\n      var _iterator3 = _createForOfIteratorHelper(object.counterpartyVersions),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var e = _step3.value;\n          message.counterpartyVersions.push(connection_1.Version.fromPartial(e));\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromPartial(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n\n    message.proofInit = (_c = object.proofInit) !== null && _c !== void 0 ? _c : new Uint8Array();\n    message.proofClient = (_d = object.proofClient) !== null && _d !== void 0 ? _d : new Uint8Array();\n    message.proofConsensus = (_e = object.proofConsensus) !== null && _e !== void 0 ? _e : new Uint8Array();\n\n    if (object.consensusHeight !== undefined && object.consensusHeight !== null) {\n      message.consensusHeight = client_1.Height.fromPartial(object.consensusHeight);\n    } else {\n      message.consensusHeight = undefined;\n    }\n\n    message.signer = (_f = object.signer) !== null && _f !== void 0 ? _f : \"\";\n    return message;\n  }\n};\nvar baseMsgConnectionOpenTryResponse = {};\nexports.MsgConnectionOpenTryResponse = {\n  encode: function encode(_) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = Object.assign({}, baseMsgConnectionOpenTryResponse);\n\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n  fromJSON: function fromJSON(_) {\n    var message = Object.assign({}, baseMsgConnectionOpenTryResponse);\n    return message;\n  },\n  toJSON: function toJSON(_) {\n    var obj = {};\n    return obj;\n  },\n  fromPartial: function fromPartial(_) {\n    var message = Object.assign({}, baseMsgConnectionOpenTryResponse);\n    return message;\n  }\n};\nvar baseMsgConnectionOpenAck = {\n  connectionId: \"\",\n  counterpartyConnectionId: \"\",\n  signer: \"\"\n};\nexports.MsgConnectionOpenAck = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n\n    if (message.connectionId !== \"\") {\n      writer.uint32(10).string(message.connectionId);\n    }\n\n    if (message.counterpartyConnectionId !== \"\") {\n      writer.uint32(18).string(message.counterpartyConnectionId);\n    }\n\n    if (message.version !== undefined) {\n      connection_1.Version.encode(message.version, writer.uint32(26).fork()).ldelim();\n    }\n\n    if (message.clientState !== undefined) {\n      any_1.Any.encode(message.clientState, writer.uint32(34).fork()).ldelim();\n    }\n\n    if (message.proofHeight !== undefined) {\n      client_1.Height.encode(message.proofHeight, writer.uint32(42).fork()).ldelim();\n    }\n\n    if (message.proofTry.length !== 0) {\n      writer.uint32(50).bytes(message.proofTry);\n    }\n\n    if (message.proofClient.length !== 0) {\n      writer.uint32(58).bytes(message.proofClient);\n    }\n\n    if (message.proofConsensus.length !== 0) {\n      writer.uint32(66).bytes(message.proofConsensus);\n    }\n\n    if (message.consensusHeight !== undefined) {\n      client_1.Height.encode(message.consensusHeight, writer.uint32(74).fork()).ldelim();\n    }\n\n    if (message.signer !== \"\") {\n      writer.uint32(82).string(message.signer);\n    }\n\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = Object.assign({}, baseMsgConnectionOpenAck);\n    message.proofTry = new Uint8Array();\n    message.proofClient = new Uint8Array();\n    message.proofConsensus = new Uint8Array();\n\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.connectionId = reader.string();\n          break;\n\n        case 2:\n          message.counterpartyConnectionId = reader.string();\n          break;\n\n        case 3:\n          message.version = connection_1.Version.decode(reader, reader.uint32());\n          break;\n\n        case 4:\n          message.clientState = any_1.Any.decode(reader, reader.uint32());\n          break;\n\n        case 5:\n          message.proofHeight = client_1.Height.decode(reader, reader.uint32());\n          break;\n\n        case 6:\n          message.proofTry = reader.bytes();\n          break;\n\n        case 7:\n          message.proofClient = reader.bytes();\n          break;\n\n        case 8:\n          message.proofConsensus = reader.bytes();\n          break;\n\n        case 9:\n          message.consensusHeight = client_1.Height.decode(reader, reader.uint32());\n          break;\n\n        case 10:\n          message.signer = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n  fromJSON: function fromJSON(object) {\n    var message = Object.assign({}, baseMsgConnectionOpenAck);\n    message.proofTry = new Uint8Array();\n    message.proofClient = new Uint8Array();\n    message.proofConsensus = new Uint8Array();\n\n    if (object.connectionId !== undefined && object.connectionId !== null) {\n      message.connectionId = String(object.connectionId);\n    } else {\n      message.connectionId = \"\";\n    }\n\n    if (object.counterpartyConnectionId !== undefined && object.counterpartyConnectionId !== null) {\n      message.counterpartyConnectionId = String(object.counterpartyConnectionId);\n    } else {\n      message.counterpartyConnectionId = \"\";\n    }\n\n    if (object.version !== undefined && object.version !== null) {\n      message.version = connection_1.Version.fromJSON(object.version);\n    } else {\n      message.version = undefined;\n    }\n\n    if (object.clientState !== undefined && object.clientState !== null) {\n      message.clientState = any_1.Any.fromJSON(object.clientState);\n    } else {\n      message.clientState = undefined;\n    }\n\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromJSON(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n\n    if (object.proofTry !== undefined && object.proofTry !== null) {\n      message.proofTry = bytesFromBase64(object.proofTry);\n    }\n\n    if (object.proofClient !== undefined && object.proofClient !== null) {\n      message.proofClient = bytesFromBase64(object.proofClient);\n    }\n\n    if (object.proofConsensus !== undefined && object.proofConsensus !== null) {\n      message.proofConsensus = bytesFromBase64(object.proofConsensus);\n    }\n\n    if (object.consensusHeight !== undefined && object.consensusHeight !== null) {\n      message.consensusHeight = client_1.Height.fromJSON(object.consensusHeight);\n    } else {\n      message.consensusHeight = undefined;\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = String(object.signer);\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  },\n  toJSON: function toJSON(message) {\n    var obj = {};\n    message.connectionId !== undefined && (obj.connectionId = message.connectionId);\n    message.counterpartyConnectionId !== undefined && (obj.counterpartyConnectionId = message.counterpartyConnectionId);\n    message.version !== undefined && (obj.version = message.version ? connection_1.Version.toJSON(message.version) : undefined);\n    message.clientState !== undefined && (obj.clientState = message.clientState ? any_1.Any.toJSON(message.clientState) : undefined);\n    message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);\n    message.proofTry !== undefined && (obj.proofTry = base64FromBytes(message.proofTry !== undefined ? message.proofTry : new Uint8Array()));\n    message.proofClient !== undefined && (obj.proofClient = base64FromBytes(message.proofClient !== undefined ? message.proofClient : new Uint8Array()));\n    message.proofConsensus !== undefined && (obj.proofConsensus = base64FromBytes(message.proofConsensus !== undefined ? message.proofConsensus : new Uint8Array()));\n    message.consensusHeight !== undefined && (obj.consensusHeight = message.consensusHeight ? client_1.Height.toJSON(message.consensusHeight) : undefined);\n    message.signer !== undefined && (obj.signer = message.signer);\n    return obj;\n  },\n  fromPartial: function fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f;\n\n    var message = Object.assign({}, baseMsgConnectionOpenAck);\n    message.connectionId = (_a = object.connectionId) !== null && _a !== void 0 ? _a : \"\";\n    message.counterpartyConnectionId = (_b = object.counterpartyConnectionId) !== null && _b !== void 0 ? _b : \"\";\n\n    if (object.version !== undefined && object.version !== null) {\n      message.version = connection_1.Version.fromPartial(object.version);\n    } else {\n      message.version = undefined;\n    }\n\n    if (object.clientState !== undefined && object.clientState !== null) {\n      message.clientState = any_1.Any.fromPartial(object.clientState);\n    } else {\n      message.clientState = undefined;\n    }\n\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromPartial(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n\n    message.proofTry = (_c = object.proofTry) !== null && _c !== void 0 ? _c : new Uint8Array();\n    message.proofClient = (_d = object.proofClient) !== null && _d !== void 0 ? _d : new Uint8Array();\n    message.proofConsensus = (_e = object.proofConsensus) !== null && _e !== void 0 ? _e : new Uint8Array();\n\n    if (object.consensusHeight !== undefined && object.consensusHeight !== null) {\n      message.consensusHeight = client_1.Height.fromPartial(object.consensusHeight);\n    } else {\n      message.consensusHeight = undefined;\n    }\n\n    message.signer = (_f = object.signer) !== null && _f !== void 0 ? _f : \"\";\n    return message;\n  }\n};\nvar baseMsgConnectionOpenAckResponse = {};\nexports.MsgConnectionOpenAckResponse = {\n  encode: function encode(_) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = Object.assign({}, baseMsgConnectionOpenAckResponse);\n\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n  fromJSON: function fromJSON(_) {\n    var message = Object.assign({}, baseMsgConnectionOpenAckResponse);\n    return message;\n  },\n  toJSON: function toJSON(_) {\n    var obj = {};\n    return obj;\n  },\n  fromPartial: function fromPartial(_) {\n    var message = Object.assign({}, baseMsgConnectionOpenAckResponse);\n    return message;\n  }\n};\nvar baseMsgConnectionOpenConfirm = {\n  connectionId: \"\",\n  signer: \"\"\n};\nexports.MsgConnectionOpenConfirm = {\n  encode: function encode(message) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n\n    if (message.connectionId !== \"\") {\n      writer.uint32(10).string(message.connectionId);\n    }\n\n    if (message.proofAck.length !== 0) {\n      writer.uint32(18).bytes(message.proofAck);\n    }\n\n    if (message.proofHeight !== undefined) {\n      client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();\n    }\n\n    if (message.signer !== \"\") {\n      writer.uint32(34).string(message.signer);\n    }\n\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = Object.assign({}, baseMsgConnectionOpenConfirm);\n    message.proofAck = new Uint8Array();\n\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.connectionId = reader.string();\n          break;\n\n        case 2:\n          message.proofAck = reader.bytes();\n          break;\n\n        case 3:\n          message.proofHeight = client_1.Height.decode(reader, reader.uint32());\n          break;\n\n        case 4:\n          message.signer = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n  fromJSON: function fromJSON(object) {\n    var message = Object.assign({}, baseMsgConnectionOpenConfirm);\n    message.proofAck = new Uint8Array();\n\n    if (object.connectionId !== undefined && object.connectionId !== null) {\n      message.connectionId = String(object.connectionId);\n    } else {\n      message.connectionId = \"\";\n    }\n\n    if (object.proofAck !== undefined && object.proofAck !== null) {\n      message.proofAck = bytesFromBase64(object.proofAck);\n    }\n\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromJSON(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = String(object.signer);\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  },\n  toJSON: function toJSON(message) {\n    var obj = {};\n    message.connectionId !== undefined && (obj.connectionId = message.connectionId);\n    message.proofAck !== undefined && (obj.proofAck = base64FromBytes(message.proofAck !== undefined ? message.proofAck : new Uint8Array()));\n    message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);\n    message.signer !== undefined && (obj.signer = message.signer);\n    return obj;\n  },\n  fromPartial: function fromPartial(object) {\n    var _a, _b, _c;\n\n    var message = Object.assign({}, baseMsgConnectionOpenConfirm);\n    message.connectionId = (_a = object.connectionId) !== null && _a !== void 0 ? _a : \"\";\n    message.proofAck = (_b = object.proofAck) !== null && _b !== void 0 ? _b : new Uint8Array();\n\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromPartial(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n\n    message.signer = (_c = object.signer) !== null && _c !== void 0 ? _c : \"\";\n    return message;\n  }\n};\nvar baseMsgConnectionOpenConfirmResponse = {};\nexports.MsgConnectionOpenConfirmResponse = {\n  encode: function encode(_) {\n    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    return writer;\n  },\n  decode: function decode(input, length) {\n    var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    var end = length === undefined ? reader.len : reader.pos + length;\n    var message = Object.assign({}, baseMsgConnectionOpenConfirmResponse);\n\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n  fromJSON: function fromJSON(_) {\n    var message = Object.assign({}, baseMsgConnectionOpenConfirmResponse);\n    return message;\n  },\n  toJSON: function toJSON(_) {\n    var obj = {};\n    return obj;\n  },\n  fromPartial: function fromPartial(_) {\n    var message = Object.assign({}, baseMsgConnectionOpenConfirmResponse);\n    return message;\n  }\n};\n\nvar MsgClientImpl = /*#__PURE__*/function () {\n  function MsgClientImpl(rpc) {\n    _classCallCheck(this, MsgClientImpl);\n\n    this.rpc = rpc;\n    this.ConnectionOpenInit = this.ConnectionOpenInit.bind(this);\n    this.ConnectionOpenTry = this.ConnectionOpenTry.bind(this);\n    this.ConnectionOpenAck = this.ConnectionOpenAck.bind(this);\n    this.ConnectionOpenConfirm = this.ConnectionOpenConfirm.bind(this);\n  }\n\n  _createClass(MsgClientImpl, [{\n    key: \"ConnectionOpenInit\",\n    value: function ConnectionOpenInit(request) {\n      var data = exports.MsgConnectionOpenInit.encode(request).finish();\n      var promise = this.rpc.request(\"ibc.core.connection.v1.Msg\", \"ConnectionOpenInit\", data);\n      return promise.then(function (data) {\n        return exports.MsgConnectionOpenInitResponse.decode(new minimal_1.default.Reader(data));\n      });\n    }\n  }, {\n    key: \"ConnectionOpenTry\",\n    value: function ConnectionOpenTry(request) {\n      var data = exports.MsgConnectionOpenTry.encode(request).finish();\n      var promise = this.rpc.request(\"ibc.core.connection.v1.Msg\", \"ConnectionOpenTry\", data);\n      return promise.then(function (data) {\n        return exports.MsgConnectionOpenTryResponse.decode(new minimal_1.default.Reader(data));\n      });\n    }\n  }, {\n    key: \"ConnectionOpenAck\",\n    value: function ConnectionOpenAck(request) {\n      var data = exports.MsgConnectionOpenAck.encode(request).finish();\n      var promise = this.rpc.request(\"ibc.core.connection.v1.Msg\", \"ConnectionOpenAck\", data);\n      return promise.then(function (data) {\n        return exports.MsgConnectionOpenAckResponse.decode(new minimal_1.default.Reader(data));\n      });\n    }\n  }, {\n    key: \"ConnectionOpenConfirm\",\n    value: function ConnectionOpenConfirm(request) {\n      var data = exports.MsgConnectionOpenConfirm.encode(request).finish();\n      var promise = this.rpc.request(\"ibc.core.connection.v1.Msg\", \"ConnectionOpenConfirm\", data);\n      return promise.then(function (data) {\n        return exports.MsgConnectionOpenConfirmResponse.decode(new minimal_1.default.Reader(data));\n      });\n    }\n  }]);\n\n  return MsgClientImpl;\n}();\n\nexports.MsgClientImpl = MsgClientImpl;\n\nvar globalThis = function () {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n}();\n\nvar atob = globalThis.atob || function (b64) {\n  return globalThis.Buffer.from(b64, \"base64\").toString(\"binary\");\n};\n\nfunction bytesFromBase64(b64) {\n  var bin = atob(b64);\n  var arr = new Uint8Array(bin.length);\n\n  for (var i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n\n  return arr;\n}\n\nvar btoa = globalThis.btoa || function (bin) {\n  return globalThis.Buffer.from(bin, \"binary\").toString(\"base64\");\n};\n\nfunction base64FromBytes(arr) {\n  var bin = [];\n\n  var _iterator4 = _createForOfIteratorHelper(arr),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var byte = _step4.value;\n      bin.push(String.fromCharCode(byte));\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n\n  return btoa(bin.join(\"\"));\n}\n\nif (minimal_1.default.util.Long !== long_1.default) {\n  minimal_1.default.util.Long = long_1.default;\n  minimal_1.default.configure();\n}","map":null,"metadata":{},"sourceType":"script"}