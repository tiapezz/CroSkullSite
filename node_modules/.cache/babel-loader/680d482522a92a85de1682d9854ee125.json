{"ast":null,"code":"/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\n\"use strict\";\n\nvar $protobuf = require(\"protobufjs/minimal\"); // Common aliases\n\n\nvar $Reader = $protobuf.Reader,\n    $Writer = $protobuf.Writer,\n    $util = $protobuf.util; // Exported root namespace\n\nvar $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n\n$root.ics23 = function () {\n  /**\n   * Namespace ics23.\n   * @exports ics23\n   * @namespace\n   */\n  var ics23 = {};\n  /**\n   * HashOp enum.\n   * @name ics23.HashOp\n   * @enum {string}\n   * @property {number} NO_HASH=0 NO_HASH value\n   * @property {number} SHA256=1 SHA256 value\n   * @property {number} SHA512=2 SHA512 value\n   * @property {number} KECCAK=3 KECCAK value\n   * @property {number} RIPEMD160=4 RIPEMD160 value\n   * @property {number} BITCOIN=5 BITCOIN value\n   * @property {number} SHA512_256=6 SHA512_256 value\n   */\n\n  ics23.HashOp = function () {\n    var valuesById = {},\n        values = Object.create(valuesById);\n    values[valuesById[0] = \"NO_HASH\"] = 0;\n    values[valuesById[1] = \"SHA256\"] = 1;\n    values[valuesById[2] = \"SHA512\"] = 2;\n    values[valuesById[3] = \"KECCAK\"] = 3;\n    values[valuesById[4] = \"RIPEMD160\"] = 4;\n    values[valuesById[5] = \"BITCOIN\"] = 5;\n    values[valuesById[6] = \"SHA512_256\"] = 6;\n    return values;\n  }();\n  /**\n   * LengthOp defines how to process the key and value of the LeafOp\n   * to include length information. After encoding the length with the given\n   * algorithm, the length will be prepended to the key and value bytes.\n   * (Each one with it's own encoded length)\n   * @name ics23.LengthOp\n   * @enum {string}\n   * @property {number} NO_PREFIX=0 NO_PREFIX value\n   * @property {number} VAR_PROTO=1 VAR_PROTO value\n   * @property {number} VAR_RLP=2 VAR_RLP value\n   * @property {number} FIXED32_BIG=3 FIXED32_BIG value\n   * @property {number} FIXED32_LITTLE=4 FIXED32_LITTLE value\n   * @property {number} FIXED64_BIG=5 FIXED64_BIG value\n   * @property {number} FIXED64_LITTLE=6 FIXED64_LITTLE value\n   * @property {number} REQUIRE_32_BYTES=7 REQUIRE_32_BYTES value\n   * @property {number} REQUIRE_64_BYTES=8 REQUIRE_64_BYTES value\n   */\n\n\n  ics23.LengthOp = function () {\n    var valuesById = {},\n        values = Object.create(valuesById);\n    values[valuesById[0] = \"NO_PREFIX\"] = 0;\n    values[valuesById[1] = \"VAR_PROTO\"] = 1;\n    values[valuesById[2] = \"VAR_RLP\"] = 2;\n    values[valuesById[3] = \"FIXED32_BIG\"] = 3;\n    values[valuesById[4] = \"FIXED32_LITTLE\"] = 4;\n    values[valuesById[5] = \"FIXED64_BIG\"] = 5;\n    values[valuesById[6] = \"FIXED64_LITTLE\"] = 6;\n    values[valuesById[7] = \"REQUIRE_32_BYTES\"] = 7;\n    values[valuesById[8] = \"REQUIRE_64_BYTES\"] = 8;\n    return values;\n  }();\n\n  ics23.ExistenceProof = function () {\n    /**\n     * Properties of an ExistenceProof.\n     * @memberof ics23\n     * @interface IExistenceProof\n     * @property {Uint8Array|null} [key] ExistenceProof key\n     * @property {Uint8Array|null} [value] ExistenceProof value\n     * @property {ics23.ILeafOp|null} [leaf] ExistenceProof leaf\n     * @property {Array.<ics23.IInnerOp>|null} [path] ExistenceProof path\n     */\n\n    /**\n     * Constructs a new ExistenceProof.\n     * @memberof ics23\n     * @classdesc ExistenceProof takes a key and a value and a set of steps to perform on it.\n     * The result of peforming all these steps will provide a \"root hash\", which can\n     * be compared to the value in a header.\n     * \n     * Since it is computationally infeasible to produce a hash collission for any of the used\n     * cryptographic hash functions, if someone can provide a series of operations to transform\n     * a given key and value into a root hash that matches some trusted root, these key and values\n     * must be in the referenced merkle tree.\n     * \n     * The only possible issue is maliablity in LeafOp, such as providing extra prefix data,\n     * which should be controlled by a spec. Eg. with lengthOp as NONE,\n     * prefix = FOO, key = BAR, value = CHOICE\n     * and\n     * prefix = F, key = OOBAR, value = CHOICE\n     * would produce the same value.\n     * \n     * With LengthOp this is tricker but not impossible. Which is why the \"leafPrefixEqual\" field\n     * in the ProofSpec is valuable to prevent this mutability. And why all trees should\n     * length-prefix the data before hashing it.\n     * @implements IExistenceProof\n     * @constructor\n     * @param {ics23.IExistenceProof=} [properties] Properties to set\n     */\n    function ExistenceProof(properties) {\n      this.path = [];\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n    }\n    /**\n     * ExistenceProof key.\n     * @member {Uint8Array} key\n     * @memberof ics23.ExistenceProof\n     * @instance\n     */\n\n\n    ExistenceProof.prototype.key = $util.newBuffer([]);\n    /**\n     * ExistenceProof value.\n     * @member {Uint8Array} value\n     * @memberof ics23.ExistenceProof\n     * @instance\n     */\n\n    ExistenceProof.prototype.value = $util.newBuffer([]);\n    /**\n     * ExistenceProof leaf.\n     * @member {ics23.ILeafOp|null|undefined} leaf\n     * @memberof ics23.ExistenceProof\n     * @instance\n     */\n\n    ExistenceProof.prototype.leaf = null;\n    /**\n     * ExistenceProof path.\n     * @member {Array.<ics23.IInnerOp>} path\n     * @memberof ics23.ExistenceProof\n     * @instance\n     */\n\n    ExistenceProof.prototype.path = $util.emptyArray;\n    /**\n     * Creates a new ExistenceProof instance using the specified properties.\n     * @function create\n     * @memberof ics23.ExistenceProof\n     * @static\n     * @param {ics23.IExistenceProof=} [properties] Properties to set\n     * @returns {ics23.ExistenceProof} ExistenceProof instance\n     */\n\n    ExistenceProof.create = function create(properties) {\n      return new ExistenceProof(properties);\n    };\n    /**\n     * Encodes the specified ExistenceProof message. Does not implicitly {@link ics23.ExistenceProof.verify|verify} messages.\n     * @function encode\n     * @memberof ics23.ExistenceProof\n     * @static\n     * @param {ics23.IExistenceProof} message ExistenceProof message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    ExistenceProof.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.key != null && message.hasOwnProperty(\"key\")) writer.uint32(\n      /* id 1, wireType 2 =*/\n      10).bytes(message.key);\n      if (message.value != null && message.hasOwnProperty(\"value\")) writer.uint32(\n      /* id 2, wireType 2 =*/\n      18).bytes(message.value);\n      if (message.leaf != null && message.hasOwnProperty(\"leaf\")) $root.ics23.LeafOp.encode(message.leaf, writer.uint32(\n      /* id 3, wireType 2 =*/\n      26).fork()).ldelim();\n      if (message.path != null && message.path.length) for (var i = 0; i < message.path.length; ++i) {\n        $root.ics23.InnerOp.encode(message.path[i], writer.uint32(\n        /* id 4, wireType 2 =*/\n        34).fork()).ldelim();\n      }\n      return writer;\n    };\n    /**\n     * Encodes the specified ExistenceProof message, length delimited. Does not implicitly {@link ics23.ExistenceProof.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof ics23.ExistenceProof\n     * @static\n     * @param {ics23.IExistenceProof} message ExistenceProof message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    ExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes an ExistenceProof message from the specified reader or buffer.\n     * @function decode\n     * @memberof ics23.ExistenceProof\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ics23.ExistenceProof} ExistenceProof\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    ExistenceProof.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.ics23.ExistenceProof();\n\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.key = reader.bytes();\n            break;\n\n          case 2:\n            message.value = reader.bytes();\n            break;\n\n          case 3:\n            message.leaf = $root.ics23.LeafOp.decode(reader, reader.uint32());\n            break;\n\n          case 4:\n            if (!(message.path && message.path.length)) message.path = [];\n            message.path.push($root.ics23.InnerOp.decode(reader, reader.uint32()));\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Decodes an ExistenceProof message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof ics23.ExistenceProof\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {ics23.ExistenceProof} ExistenceProof\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    ExistenceProof.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies an ExistenceProof message.\n     * @function verify\n     * @memberof ics23.ExistenceProof\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n\n\n    ExistenceProof.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n      if (message.key != null && message.hasOwnProperty(\"key\")) if (!(message.key && typeof message.key.length === \"number\" || $util.isString(message.key))) return \"key: buffer expected\";\n      if (message.value != null && message.hasOwnProperty(\"value\")) if (!(message.value && typeof message.value.length === \"number\" || $util.isString(message.value))) return \"value: buffer expected\";\n\n      if (message.leaf != null && message.hasOwnProperty(\"leaf\")) {\n        var error = $root.ics23.LeafOp.verify(message.leaf);\n        if (error) return \"leaf.\" + error;\n      }\n\n      if (message.path != null && message.hasOwnProperty(\"path\")) {\n        if (!Array.isArray(message.path)) return \"path: array expected\";\n\n        for (var i = 0; i < message.path.length; ++i) {\n          var error = $root.ics23.InnerOp.verify(message.path[i]);\n          if (error) return \"path.\" + error;\n        }\n      }\n\n      return null;\n    };\n    /**\n     * Creates an ExistenceProof message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof ics23.ExistenceProof\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {ics23.ExistenceProof} ExistenceProof\n     */\n\n\n    ExistenceProof.fromObject = function fromObject(object) {\n      if (object instanceof $root.ics23.ExistenceProof) return object;\n      var message = new $root.ics23.ExistenceProof();\n      if (object.key != null) if (typeof object.key === \"string\") $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);else if (object.key.length) message.key = object.key;\n      if (object.value != null) if (typeof object.value === \"string\") $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);else if (object.value.length) message.value = object.value;\n\n      if (object.leaf != null) {\n        if (typeof object.leaf !== \"object\") throw TypeError(\".ics23.ExistenceProof.leaf: object expected\");\n        message.leaf = $root.ics23.LeafOp.fromObject(object.leaf);\n      }\n\n      if (object.path) {\n        if (!Array.isArray(object.path)) throw TypeError(\".ics23.ExistenceProof.path: array expected\");\n        message.path = [];\n\n        for (var i = 0; i < object.path.length; ++i) {\n          if (typeof object.path[i] !== \"object\") throw TypeError(\".ics23.ExistenceProof.path: object expected\");\n          message.path[i] = $root.ics23.InnerOp.fromObject(object.path[i]);\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Creates a plain object from an ExistenceProof message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof ics23.ExistenceProof\n     * @static\n     * @param {ics23.ExistenceProof} message ExistenceProof\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    ExistenceProof.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n      if (options.arrays || options.defaults) object.path = [];\n\n      if (options.defaults) {\n        if (options.bytes === String) object.key = \"\";else {\n          object.key = [];\n          if (options.bytes !== Array) object.key = $util.newBuffer(object.key);\n        }\n        if (options.bytes === String) object.value = \"\";else {\n          object.value = [];\n          if (options.bytes !== Array) object.value = $util.newBuffer(object.value);\n        }\n        object.leaf = null;\n      }\n\n      if (message.key != null && message.hasOwnProperty(\"key\")) object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;\n      if (message.value != null && message.hasOwnProperty(\"value\")) object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;\n      if (message.leaf != null && message.hasOwnProperty(\"leaf\")) object.leaf = $root.ics23.LeafOp.toObject(message.leaf, options);\n\n      if (message.path && message.path.length) {\n        object.path = [];\n\n        for (var j = 0; j < message.path.length; ++j) {\n          object.path[j] = $root.ics23.InnerOp.toObject(message.path[j], options);\n        }\n      }\n\n      return object;\n    };\n    /**\n     * Converts this ExistenceProof to JSON.\n     * @function toJSON\n     * @memberof ics23.ExistenceProof\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    ExistenceProof.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return ExistenceProof;\n  }();\n\n  ics23.NonExistenceProof = function () {\n    /**\n     * Properties of a NonExistenceProof.\n     * @memberof ics23\n     * @interface INonExistenceProof\n     * @property {Uint8Array|null} [key] NonExistenceProof key\n     * @property {ics23.IExistenceProof|null} [left] NonExistenceProof left\n     * @property {ics23.IExistenceProof|null} [right] NonExistenceProof right\n     */\n\n    /**\n     * Constructs a new NonExistenceProof.\n     * @memberof ics23\n     * @classdesc Represents a NonExistenceProof.\n     * @implements INonExistenceProof\n     * @constructor\n     * @param {ics23.INonExistenceProof=} [properties] Properties to set\n     */\n    function NonExistenceProof(properties) {\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n    }\n    /**\n     * NonExistenceProof key.\n     * @member {Uint8Array} key\n     * @memberof ics23.NonExistenceProof\n     * @instance\n     */\n\n\n    NonExistenceProof.prototype.key = $util.newBuffer([]);\n    /**\n     * NonExistenceProof left.\n     * @member {ics23.IExistenceProof|null|undefined} left\n     * @memberof ics23.NonExistenceProof\n     * @instance\n     */\n\n    NonExistenceProof.prototype.left = null;\n    /**\n     * NonExistenceProof right.\n     * @member {ics23.IExistenceProof|null|undefined} right\n     * @memberof ics23.NonExistenceProof\n     * @instance\n     */\n\n    NonExistenceProof.prototype.right = null;\n    /**\n     * Creates a new NonExistenceProof instance using the specified properties.\n     * @function create\n     * @memberof ics23.NonExistenceProof\n     * @static\n     * @param {ics23.INonExistenceProof=} [properties] Properties to set\n     * @returns {ics23.NonExistenceProof} NonExistenceProof instance\n     */\n\n    NonExistenceProof.create = function create(properties) {\n      return new NonExistenceProof(properties);\n    };\n    /**\n     * Encodes the specified NonExistenceProof message. Does not implicitly {@link ics23.NonExistenceProof.verify|verify} messages.\n     * @function encode\n     * @memberof ics23.NonExistenceProof\n     * @static\n     * @param {ics23.INonExistenceProof} message NonExistenceProof message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    NonExistenceProof.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.key != null && message.hasOwnProperty(\"key\")) writer.uint32(\n      /* id 1, wireType 2 =*/\n      10).bytes(message.key);\n      if (message.left != null && message.hasOwnProperty(\"left\")) $root.ics23.ExistenceProof.encode(message.left, writer.uint32(\n      /* id 2, wireType 2 =*/\n      18).fork()).ldelim();\n      if (message.right != null && message.hasOwnProperty(\"right\")) $root.ics23.ExistenceProof.encode(message.right, writer.uint32(\n      /* id 3, wireType 2 =*/\n      26).fork()).ldelim();\n      return writer;\n    };\n    /**\n     * Encodes the specified NonExistenceProof message, length delimited. Does not implicitly {@link ics23.NonExistenceProof.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof ics23.NonExistenceProof\n     * @static\n     * @param {ics23.INonExistenceProof} message NonExistenceProof message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    NonExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes a NonExistenceProof message from the specified reader or buffer.\n     * @function decode\n     * @memberof ics23.NonExistenceProof\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ics23.NonExistenceProof} NonExistenceProof\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    NonExistenceProof.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.ics23.NonExistenceProof();\n\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.key = reader.bytes();\n            break;\n\n          case 2:\n            message.left = $root.ics23.ExistenceProof.decode(reader, reader.uint32());\n            break;\n\n          case 3:\n            message.right = $root.ics23.ExistenceProof.decode(reader, reader.uint32());\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Decodes a NonExistenceProof message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof ics23.NonExistenceProof\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {ics23.NonExistenceProof} NonExistenceProof\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    NonExistenceProof.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies a NonExistenceProof message.\n     * @function verify\n     * @memberof ics23.NonExistenceProof\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n\n\n    NonExistenceProof.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n      if (message.key != null && message.hasOwnProperty(\"key\")) if (!(message.key && typeof message.key.length === \"number\" || $util.isString(message.key))) return \"key: buffer expected\";\n\n      if (message.left != null && message.hasOwnProperty(\"left\")) {\n        var error = $root.ics23.ExistenceProof.verify(message.left);\n        if (error) return \"left.\" + error;\n      }\n\n      if (message.right != null && message.hasOwnProperty(\"right\")) {\n        var error = $root.ics23.ExistenceProof.verify(message.right);\n        if (error) return \"right.\" + error;\n      }\n\n      return null;\n    };\n    /**\n     * Creates a NonExistenceProof message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof ics23.NonExistenceProof\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {ics23.NonExistenceProof} NonExistenceProof\n     */\n\n\n    NonExistenceProof.fromObject = function fromObject(object) {\n      if (object instanceof $root.ics23.NonExistenceProof) return object;\n      var message = new $root.ics23.NonExistenceProof();\n      if (object.key != null) if (typeof object.key === \"string\") $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);else if (object.key.length) message.key = object.key;\n\n      if (object.left != null) {\n        if (typeof object.left !== \"object\") throw TypeError(\".ics23.NonExistenceProof.left: object expected\");\n        message.left = $root.ics23.ExistenceProof.fromObject(object.left);\n      }\n\n      if (object.right != null) {\n        if (typeof object.right !== \"object\") throw TypeError(\".ics23.NonExistenceProof.right: object expected\");\n        message.right = $root.ics23.ExistenceProof.fromObject(object.right);\n      }\n\n      return message;\n    };\n    /**\n     * Creates a plain object from a NonExistenceProof message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof ics23.NonExistenceProof\n     * @static\n     * @param {ics23.NonExistenceProof} message NonExistenceProof\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    NonExistenceProof.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n\n      if (options.defaults) {\n        if (options.bytes === String) object.key = \"\";else {\n          object.key = [];\n          if (options.bytes !== Array) object.key = $util.newBuffer(object.key);\n        }\n        object.left = null;\n        object.right = null;\n      }\n\n      if (message.key != null && message.hasOwnProperty(\"key\")) object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;\n      if (message.left != null && message.hasOwnProperty(\"left\")) object.left = $root.ics23.ExistenceProof.toObject(message.left, options);\n      if (message.right != null && message.hasOwnProperty(\"right\")) object.right = $root.ics23.ExistenceProof.toObject(message.right, options);\n      return object;\n    };\n    /**\n     * Converts this NonExistenceProof to JSON.\n     * @function toJSON\n     * @memberof ics23.NonExistenceProof\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    NonExistenceProof.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return NonExistenceProof;\n  }();\n\n  ics23.CommitmentProof = function () {\n    /**\n     * Properties of a CommitmentProof.\n     * @memberof ics23\n     * @interface ICommitmentProof\n     * @property {ics23.IExistenceProof|null} [exist] CommitmentProof exist\n     * @property {ics23.INonExistenceProof|null} [nonexist] CommitmentProof nonexist\n     * @property {ics23.IBatchProof|null} [batch] CommitmentProof batch\n     * @property {ics23.ICompressedBatchProof|null} [compressed] CommitmentProof compressed\n     */\n\n    /**\n     * Constructs a new CommitmentProof.\n     * @memberof ics23\n     * @classdesc Represents a CommitmentProof.\n     * @implements ICommitmentProof\n     * @constructor\n     * @param {ics23.ICommitmentProof=} [properties] Properties to set\n     */\n    function CommitmentProof(properties) {\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n    }\n    /**\n     * CommitmentProof exist.\n     * @member {ics23.IExistenceProof|null|undefined} exist\n     * @memberof ics23.CommitmentProof\n     * @instance\n     */\n\n\n    CommitmentProof.prototype.exist = null;\n    /**\n     * CommitmentProof nonexist.\n     * @member {ics23.INonExistenceProof|null|undefined} nonexist\n     * @memberof ics23.CommitmentProof\n     * @instance\n     */\n\n    CommitmentProof.prototype.nonexist = null;\n    /**\n     * CommitmentProof batch.\n     * @member {ics23.IBatchProof|null|undefined} batch\n     * @memberof ics23.CommitmentProof\n     * @instance\n     */\n\n    CommitmentProof.prototype.batch = null;\n    /**\n     * CommitmentProof compressed.\n     * @member {ics23.ICompressedBatchProof|null|undefined} compressed\n     * @memberof ics23.CommitmentProof\n     * @instance\n     */\n\n    CommitmentProof.prototype.compressed = null; // OneOf field names bound to virtual getters and setters\n\n    var $oneOfFields;\n    /**\n     * CommitmentProof proof.\n     * @member {\"exist\"|\"nonexist\"|\"batch\"|\"compressed\"|undefined} proof\n     * @memberof ics23.CommitmentProof\n     * @instance\n     */\n\n    Object.defineProperty(CommitmentProof.prototype, \"proof\", {\n      get: $util.oneOfGetter($oneOfFields = [\"exist\", \"nonexist\", \"batch\", \"compressed\"]),\n      set: $util.oneOfSetter($oneOfFields)\n    });\n    /**\n     * Creates a new CommitmentProof instance using the specified properties.\n     * @function create\n     * @memberof ics23.CommitmentProof\n     * @static\n     * @param {ics23.ICommitmentProof=} [properties] Properties to set\n     * @returns {ics23.CommitmentProof} CommitmentProof instance\n     */\n\n    CommitmentProof.create = function create(properties) {\n      return new CommitmentProof(properties);\n    };\n    /**\n     * Encodes the specified CommitmentProof message. Does not implicitly {@link ics23.CommitmentProof.verify|verify} messages.\n     * @function encode\n     * @memberof ics23.CommitmentProof\n     * @static\n     * @param {ics23.ICommitmentProof} message CommitmentProof message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    CommitmentProof.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.exist != null && message.hasOwnProperty(\"exist\")) $root.ics23.ExistenceProof.encode(message.exist, writer.uint32(\n      /* id 1, wireType 2 =*/\n      10).fork()).ldelim();\n      if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) $root.ics23.NonExistenceProof.encode(message.nonexist, writer.uint32(\n      /* id 2, wireType 2 =*/\n      18).fork()).ldelim();\n      if (message.batch != null && message.hasOwnProperty(\"batch\")) $root.ics23.BatchProof.encode(message.batch, writer.uint32(\n      /* id 3, wireType 2 =*/\n      26).fork()).ldelim();\n      if (message.compressed != null && message.hasOwnProperty(\"compressed\")) $root.ics23.CompressedBatchProof.encode(message.compressed, writer.uint32(\n      /* id 4, wireType 2 =*/\n      34).fork()).ldelim();\n      return writer;\n    };\n    /**\n     * Encodes the specified CommitmentProof message, length delimited. Does not implicitly {@link ics23.CommitmentProof.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof ics23.CommitmentProof\n     * @static\n     * @param {ics23.ICommitmentProof} message CommitmentProof message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    CommitmentProof.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes a CommitmentProof message from the specified reader or buffer.\n     * @function decode\n     * @memberof ics23.CommitmentProof\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ics23.CommitmentProof} CommitmentProof\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    CommitmentProof.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.ics23.CommitmentProof();\n\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.exist = $root.ics23.ExistenceProof.decode(reader, reader.uint32());\n            break;\n\n          case 2:\n            message.nonexist = $root.ics23.NonExistenceProof.decode(reader, reader.uint32());\n            break;\n\n          case 3:\n            message.batch = $root.ics23.BatchProof.decode(reader, reader.uint32());\n            break;\n\n          case 4:\n            message.compressed = $root.ics23.CompressedBatchProof.decode(reader, reader.uint32());\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Decodes a CommitmentProof message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof ics23.CommitmentProof\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {ics23.CommitmentProof} CommitmentProof\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    CommitmentProof.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies a CommitmentProof message.\n     * @function verify\n     * @memberof ics23.CommitmentProof\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n\n\n    CommitmentProof.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n      var properties = {};\n\n      if (message.exist != null && message.hasOwnProperty(\"exist\")) {\n        properties.proof = 1;\n        {\n          var error = $root.ics23.ExistenceProof.verify(message.exist);\n          if (error) return \"exist.\" + error;\n        }\n      }\n\n      if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) {\n        if (properties.proof === 1) return \"proof: multiple values\";\n        properties.proof = 1;\n        {\n          var error = $root.ics23.NonExistenceProof.verify(message.nonexist);\n          if (error) return \"nonexist.\" + error;\n        }\n      }\n\n      if (message.batch != null && message.hasOwnProperty(\"batch\")) {\n        if (properties.proof === 1) return \"proof: multiple values\";\n        properties.proof = 1;\n        {\n          var error = $root.ics23.BatchProof.verify(message.batch);\n          if (error) return \"batch.\" + error;\n        }\n      }\n\n      if (message.compressed != null && message.hasOwnProperty(\"compressed\")) {\n        if (properties.proof === 1) return \"proof: multiple values\";\n        properties.proof = 1;\n        {\n          var error = $root.ics23.CompressedBatchProof.verify(message.compressed);\n          if (error) return \"compressed.\" + error;\n        }\n      }\n\n      return null;\n    };\n    /**\n     * Creates a CommitmentProof message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof ics23.CommitmentProof\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {ics23.CommitmentProof} CommitmentProof\n     */\n\n\n    CommitmentProof.fromObject = function fromObject(object) {\n      if (object instanceof $root.ics23.CommitmentProof) return object;\n      var message = new $root.ics23.CommitmentProof();\n\n      if (object.exist != null) {\n        if (typeof object.exist !== \"object\") throw TypeError(\".ics23.CommitmentProof.exist: object expected\");\n        message.exist = $root.ics23.ExistenceProof.fromObject(object.exist);\n      }\n\n      if (object.nonexist != null) {\n        if (typeof object.nonexist !== \"object\") throw TypeError(\".ics23.CommitmentProof.nonexist: object expected\");\n        message.nonexist = $root.ics23.NonExistenceProof.fromObject(object.nonexist);\n      }\n\n      if (object.batch != null) {\n        if (typeof object.batch !== \"object\") throw TypeError(\".ics23.CommitmentProof.batch: object expected\");\n        message.batch = $root.ics23.BatchProof.fromObject(object.batch);\n      }\n\n      if (object.compressed != null) {\n        if (typeof object.compressed !== \"object\") throw TypeError(\".ics23.CommitmentProof.compressed: object expected\");\n        message.compressed = $root.ics23.CompressedBatchProof.fromObject(object.compressed);\n      }\n\n      return message;\n    };\n    /**\n     * Creates a plain object from a CommitmentProof message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof ics23.CommitmentProof\n     * @static\n     * @param {ics23.CommitmentProof} message CommitmentProof\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    CommitmentProof.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n\n      if (message.exist != null && message.hasOwnProperty(\"exist\")) {\n        object.exist = $root.ics23.ExistenceProof.toObject(message.exist, options);\n        if (options.oneofs) object.proof = \"exist\";\n      }\n\n      if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) {\n        object.nonexist = $root.ics23.NonExistenceProof.toObject(message.nonexist, options);\n        if (options.oneofs) object.proof = \"nonexist\";\n      }\n\n      if (message.batch != null && message.hasOwnProperty(\"batch\")) {\n        object.batch = $root.ics23.BatchProof.toObject(message.batch, options);\n        if (options.oneofs) object.proof = \"batch\";\n      }\n\n      if (message.compressed != null && message.hasOwnProperty(\"compressed\")) {\n        object.compressed = $root.ics23.CompressedBatchProof.toObject(message.compressed, options);\n        if (options.oneofs) object.proof = \"compressed\";\n      }\n\n      return object;\n    };\n    /**\n     * Converts this CommitmentProof to JSON.\n     * @function toJSON\n     * @memberof ics23.CommitmentProof\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    CommitmentProof.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return CommitmentProof;\n  }();\n\n  ics23.LeafOp = function () {\n    /**\n     * Properties of a LeafOp.\n     * @memberof ics23\n     * @interface ILeafOp\n     * @property {ics23.HashOp|null} [hash] LeafOp hash\n     * @property {ics23.HashOp|null} [prehashKey] LeafOp prehashKey\n     * @property {ics23.HashOp|null} [prehashValue] LeafOp prehashValue\n     * @property {ics23.LengthOp|null} [length] LeafOp length\n     * @property {Uint8Array|null} [prefix] LeafOp prefix\n     */\n\n    /**\n     * Constructs a new LeafOp.\n     * @memberof ics23\n     * @classdesc LeafOp represents the raw key-value data we wish to prove, and\n     * must be flexible to represent the internal transformation from\n     * the original key-value pairs into the basis hash, for many existing\n     * merkle trees.\n     * \n     * key and value are passed in. So that the signature of this operation is:\n     * leafOp(key, value) -> output\n     * \n     * To process this, first prehash the keys and values if needed (ANY means no hash in this case):\n     * hkey = prehashKey(key)\n     * hvalue = prehashValue(value)\n     * \n     * Then combine the bytes, and hash it\n     * output = hash(prefix || length(hkey) || hkey || length(hvalue) || hvalue)\n     * @implements ILeafOp\n     * @constructor\n     * @param {ics23.ILeafOp=} [properties] Properties to set\n     */\n    function LeafOp(properties) {\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n    }\n    /**\n     * LeafOp hash.\n     * @member {ics23.HashOp} hash\n     * @memberof ics23.LeafOp\n     * @instance\n     */\n\n\n    LeafOp.prototype.hash = 0;\n    /**\n     * LeafOp prehashKey.\n     * @member {ics23.HashOp} prehashKey\n     * @memberof ics23.LeafOp\n     * @instance\n     */\n\n    LeafOp.prototype.prehashKey = 0;\n    /**\n     * LeafOp prehashValue.\n     * @member {ics23.HashOp} prehashValue\n     * @memberof ics23.LeafOp\n     * @instance\n     */\n\n    LeafOp.prototype.prehashValue = 0;\n    /**\n     * LeafOp length.\n     * @member {ics23.LengthOp} length\n     * @memberof ics23.LeafOp\n     * @instance\n     */\n\n    LeafOp.prototype.length = 0;\n    /**\n     * LeafOp prefix.\n     * @member {Uint8Array} prefix\n     * @memberof ics23.LeafOp\n     * @instance\n     */\n\n    LeafOp.prototype.prefix = $util.newBuffer([]);\n    /**\n     * Creates a new LeafOp instance using the specified properties.\n     * @function create\n     * @memberof ics23.LeafOp\n     * @static\n     * @param {ics23.ILeafOp=} [properties] Properties to set\n     * @returns {ics23.LeafOp} LeafOp instance\n     */\n\n    LeafOp.create = function create(properties) {\n      return new LeafOp(properties);\n    };\n    /**\n     * Encodes the specified LeafOp message. Does not implicitly {@link ics23.LeafOp.verify|verify} messages.\n     * @function encode\n     * @memberof ics23.LeafOp\n     * @static\n     * @param {ics23.ILeafOp} message LeafOp message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    LeafOp.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.hash != null && message.hasOwnProperty(\"hash\")) writer.uint32(\n      /* id 1, wireType 0 =*/\n      8).int32(message.hash);\n      if (message.prehashKey != null && message.hasOwnProperty(\"prehashKey\")) writer.uint32(\n      /* id 2, wireType 0 =*/\n      16).int32(message.prehashKey);\n      if (message.prehashValue != null && message.hasOwnProperty(\"prehashValue\")) writer.uint32(\n      /* id 3, wireType 0 =*/\n      24).int32(message.prehashValue);\n      if (message.length != null && message.hasOwnProperty(\"length\")) writer.uint32(\n      /* id 4, wireType 0 =*/\n      32).int32(message.length);\n      if (message.prefix != null && message.hasOwnProperty(\"prefix\")) writer.uint32(\n      /* id 5, wireType 2 =*/\n      42).bytes(message.prefix);\n      return writer;\n    };\n    /**\n     * Encodes the specified LeafOp message, length delimited. Does not implicitly {@link ics23.LeafOp.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof ics23.LeafOp\n     * @static\n     * @param {ics23.ILeafOp} message LeafOp message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    LeafOp.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes a LeafOp message from the specified reader or buffer.\n     * @function decode\n     * @memberof ics23.LeafOp\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ics23.LeafOp} LeafOp\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    LeafOp.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.ics23.LeafOp();\n\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.hash = reader.int32();\n            break;\n\n          case 2:\n            message.prehashKey = reader.int32();\n            break;\n\n          case 3:\n            message.prehashValue = reader.int32();\n            break;\n\n          case 4:\n            message.length = reader.int32();\n            break;\n\n          case 5:\n            message.prefix = reader.bytes();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Decodes a LeafOp message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof ics23.LeafOp\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {ics23.LeafOp} LeafOp\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    LeafOp.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies a LeafOp message.\n     * @function verify\n     * @memberof ics23.LeafOp\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n\n\n    LeafOp.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n      if (message.hash != null && message.hasOwnProperty(\"hash\")) switch (message.hash) {\n        default:\n          return \"hash: enum value expected\";\n\n        case 0:\n        case 1:\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n          break;\n      }\n      if (message.prehashKey != null && message.hasOwnProperty(\"prehashKey\")) switch (message.prehashKey) {\n        default:\n          return \"prehashKey: enum value expected\";\n\n        case 0:\n        case 1:\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n          break;\n      }\n      if (message.prehashValue != null && message.hasOwnProperty(\"prehashValue\")) switch (message.prehashValue) {\n        default:\n          return \"prehashValue: enum value expected\";\n\n        case 0:\n        case 1:\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n          break;\n      }\n      if (message.length != null && message.hasOwnProperty(\"length\")) switch (message.length) {\n        default:\n          return \"length: enum value expected\";\n\n        case 0:\n        case 1:\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n          break;\n      }\n      if (message.prefix != null && message.hasOwnProperty(\"prefix\")) if (!(message.prefix && typeof message.prefix.length === \"number\" || $util.isString(message.prefix))) return \"prefix: buffer expected\";\n      return null;\n    };\n    /**\n     * Creates a LeafOp message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof ics23.LeafOp\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {ics23.LeafOp} LeafOp\n     */\n\n\n    LeafOp.fromObject = function fromObject(object) {\n      if (object instanceof $root.ics23.LeafOp) return object;\n      var message = new $root.ics23.LeafOp();\n\n      switch (object.hash) {\n        case \"NO_HASH\":\n        case 0:\n          message.hash = 0;\n          break;\n\n        case \"SHA256\":\n        case 1:\n          message.hash = 1;\n          break;\n\n        case \"SHA512\":\n        case 2:\n          message.hash = 2;\n          break;\n\n        case \"KECCAK\":\n        case 3:\n          message.hash = 3;\n          break;\n\n        case \"RIPEMD160\":\n        case 4:\n          message.hash = 4;\n          break;\n\n        case \"BITCOIN\":\n        case 5:\n          message.hash = 5;\n          break;\n\n        case \"SHA512_256\":\n        case 6:\n          message.hash = 6;\n          break;\n      }\n\n      switch (object.prehashKey) {\n        case \"NO_HASH\":\n        case 0:\n          message.prehashKey = 0;\n          break;\n\n        case \"SHA256\":\n        case 1:\n          message.prehashKey = 1;\n          break;\n\n        case \"SHA512\":\n        case 2:\n          message.prehashKey = 2;\n          break;\n\n        case \"KECCAK\":\n        case 3:\n          message.prehashKey = 3;\n          break;\n\n        case \"RIPEMD160\":\n        case 4:\n          message.prehashKey = 4;\n          break;\n\n        case \"BITCOIN\":\n        case 5:\n          message.prehashKey = 5;\n          break;\n\n        case \"SHA512_256\":\n        case 6:\n          message.prehashKey = 6;\n          break;\n      }\n\n      switch (object.prehashValue) {\n        case \"NO_HASH\":\n        case 0:\n          message.prehashValue = 0;\n          break;\n\n        case \"SHA256\":\n        case 1:\n          message.prehashValue = 1;\n          break;\n\n        case \"SHA512\":\n        case 2:\n          message.prehashValue = 2;\n          break;\n\n        case \"KECCAK\":\n        case 3:\n          message.prehashValue = 3;\n          break;\n\n        case \"RIPEMD160\":\n        case 4:\n          message.prehashValue = 4;\n          break;\n\n        case \"BITCOIN\":\n        case 5:\n          message.prehashValue = 5;\n          break;\n\n        case \"SHA512_256\":\n        case 6:\n          message.prehashValue = 6;\n          break;\n      }\n\n      switch (object.length) {\n        case \"NO_PREFIX\":\n        case 0:\n          message.length = 0;\n          break;\n\n        case \"VAR_PROTO\":\n        case 1:\n          message.length = 1;\n          break;\n\n        case \"VAR_RLP\":\n        case 2:\n          message.length = 2;\n          break;\n\n        case \"FIXED32_BIG\":\n        case 3:\n          message.length = 3;\n          break;\n\n        case \"FIXED32_LITTLE\":\n        case 4:\n          message.length = 4;\n          break;\n\n        case \"FIXED64_BIG\":\n        case 5:\n          message.length = 5;\n          break;\n\n        case \"FIXED64_LITTLE\":\n        case 6:\n          message.length = 6;\n          break;\n\n        case \"REQUIRE_32_BYTES\":\n        case 7:\n          message.length = 7;\n          break;\n\n        case \"REQUIRE_64_BYTES\":\n        case 8:\n          message.length = 8;\n          break;\n      }\n\n      if (object.prefix != null) if (typeof object.prefix === \"string\") $util.base64.decode(object.prefix, message.prefix = $util.newBuffer($util.base64.length(object.prefix)), 0);else if (object.prefix.length) message.prefix = object.prefix;\n      return message;\n    };\n    /**\n     * Creates a plain object from a LeafOp message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof ics23.LeafOp\n     * @static\n     * @param {ics23.LeafOp} message LeafOp\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    LeafOp.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n\n      if (options.defaults) {\n        object.hash = options.enums === String ? \"NO_HASH\" : 0;\n        object.prehashKey = options.enums === String ? \"NO_HASH\" : 0;\n        object.prehashValue = options.enums === String ? \"NO_HASH\" : 0;\n        object.length = options.enums === String ? \"NO_PREFIX\" : 0;\n        if (options.bytes === String) object.prefix = \"\";else {\n          object.prefix = [];\n          if (options.bytes !== Array) object.prefix = $util.newBuffer(object.prefix);\n        }\n      }\n\n      if (message.hash != null && message.hasOwnProperty(\"hash\")) object.hash = options.enums === String ? $root.ics23.HashOp[message.hash] : message.hash;\n      if (message.prehashKey != null && message.hasOwnProperty(\"prehashKey\")) object.prehashKey = options.enums === String ? $root.ics23.HashOp[message.prehashKey] : message.prehashKey;\n      if (message.prehashValue != null && message.hasOwnProperty(\"prehashValue\")) object.prehashValue = options.enums === String ? $root.ics23.HashOp[message.prehashValue] : message.prehashValue;\n      if (message.length != null && message.hasOwnProperty(\"length\")) object.length = options.enums === String ? $root.ics23.LengthOp[message.length] : message.length;\n      if (message.prefix != null && message.hasOwnProperty(\"prefix\")) object.prefix = options.bytes === String ? $util.base64.encode(message.prefix, 0, message.prefix.length) : options.bytes === Array ? Array.prototype.slice.call(message.prefix) : message.prefix;\n      return object;\n    };\n    /**\n     * Converts this LeafOp to JSON.\n     * @function toJSON\n     * @memberof ics23.LeafOp\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    LeafOp.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return LeafOp;\n  }();\n\n  ics23.InnerOp = function () {\n    /**\n     * Properties of an InnerOp.\n     * @memberof ics23\n     * @interface IInnerOp\n     * @property {ics23.HashOp|null} [hash] InnerOp hash\n     * @property {Uint8Array|null} [prefix] InnerOp prefix\n     * @property {Uint8Array|null} [suffix] InnerOp suffix\n     */\n\n    /**\n     * Constructs a new InnerOp.\n     * @memberof ics23\n     * @classdesc InnerOp represents a merkle-proof step that is not a leaf.\n     * It represents concatenating two children and hashing them to provide the next result.\n     * \n     * The result of the previous step is passed in, so the signature of this op is:\n     * innerOp(child) -> output\n     * \n     * The result of applying InnerOp should be:\n     * output = op.hash(op.prefix || child || op.suffix)\n     * \n     * where the || operator is concatenation of binary data,\n     * and child is the result of hashing all the tree below this step.\n     * \n     * Any special data, like prepending child with the length, or prepending the entire operation with\n     * some value to differentiate from leaf nodes, should be included in prefix and suffix.\n     * If either of prefix or suffix is empty, we just treat it as an empty string\n     * @implements IInnerOp\n     * @constructor\n     * @param {ics23.IInnerOp=} [properties] Properties to set\n     */\n    function InnerOp(properties) {\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n    }\n    /**\n     * InnerOp hash.\n     * @member {ics23.HashOp} hash\n     * @memberof ics23.InnerOp\n     * @instance\n     */\n\n\n    InnerOp.prototype.hash = 0;\n    /**\n     * InnerOp prefix.\n     * @member {Uint8Array} prefix\n     * @memberof ics23.InnerOp\n     * @instance\n     */\n\n    InnerOp.prototype.prefix = $util.newBuffer([]);\n    /**\n     * InnerOp suffix.\n     * @member {Uint8Array} suffix\n     * @memberof ics23.InnerOp\n     * @instance\n     */\n\n    InnerOp.prototype.suffix = $util.newBuffer([]);\n    /**\n     * Creates a new InnerOp instance using the specified properties.\n     * @function create\n     * @memberof ics23.InnerOp\n     * @static\n     * @param {ics23.IInnerOp=} [properties] Properties to set\n     * @returns {ics23.InnerOp} InnerOp instance\n     */\n\n    InnerOp.create = function create(properties) {\n      return new InnerOp(properties);\n    };\n    /**\n     * Encodes the specified InnerOp message. Does not implicitly {@link ics23.InnerOp.verify|verify} messages.\n     * @function encode\n     * @memberof ics23.InnerOp\n     * @static\n     * @param {ics23.IInnerOp} message InnerOp message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    InnerOp.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.hash != null && message.hasOwnProperty(\"hash\")) writer.uint32(\n      /* id 1, wireType 0 =*/\n      8).int32(message.hash);\n      if (message.prefix != null && message.hasOwnProperty(\"prefix\")) writer.uint32(\n      /* id 2, wireType 2 =*/\n      18).bytes(message.prefix);\n      if (message.suffix != null && message.hasOwnProperty(\"suffix\")) writer.uint32(\n      /* id 3, wireType 2 =*/\n      26).bytes(message.suffix);\n      return writer;\n    };\n    /**\n     * Encodes the specified InnerOp message, length delimited. Does not implicitly {@link ics23.InnerOp.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof ics23.InnerOp\n     * @static\n     * @param {ics23.IInnerOp} message InnerOp message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    InnerOp.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes an InnerOp message from the specified reader or buffer.\n     * @function decode\n     * @memberof ics23.InnerOp\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ics23.InnerOp} InnerOp\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    InnerOp.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.ics23.InnerOp();\n\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.hash = reader.int32();\n            break;\n\n          case 2:\n            message.prefix = reader.bytes();\n            break;\n\n          case 3:\n            message.suffix = reader.bytes();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Decodes an InnerOp message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof ics23.InnerOp\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {ics23.InnerOp} InnerOp\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    InnerOp.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies an InnerOp message.\n     * @function verify\n     * @memberof ics23.InnerOp\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n\n\n    InnerOp.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n      if (message.hash != null && message.hasOwnProperty(\"hash\")) switch (message.hash) {\n        default:\n          return \"hash: enum value expected\";\n\n        case 0:\n        case 1:\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n          break;\n      }\n      if (message.prefix != null && message.hasOwnProperty(\"prefix\")) if (!(message.prefix && typeof message.prefix.length === \"number\" || $util.isString(message.prefix))) return \"prefix: buffer expected\";\n      if (message.suffix != null && message.hasOwnProperty(\"suffix\")) if (!(message.suffix && typeof message.suffix.length === \"number\" || $util.isString(message.suffix))) return \"suffix: buffer expected\";\n      return null;\n    };\n    /**\n     * Creates an InnerOp message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof ics23.InnerOp\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {ics23.InnerOp} InnerOp\n     */\n\n\n    InnerOp.fromObject = function fromObject(object) {\n      if (object instanceof $root.ics23.InnerOp) return object;\n      var message = new $root.ics23.InnerOp();\n\n      switch (object.hash) {\n        case \"NO_HASH\":\n        case 0:\n          message.hash = 0;\n          break;\n\n        case \"SHA256\":\n        case 1:\n          message.hash = 1;\n          break;\n\n        case \"SHA512\":\n        case 2:\n          message.hash = 2;\n          break;\n\n        case \"KECCAK\":\n        case 3:\n          message.hash = 3;\n          break;\n\n        case \"RIPEMD160\":\n        case 4:\n          message.hash = 4;\n          break;\n\n        case \"BITCOIN\":\n        case 5:\n          message.hash = 5;\n          break;\n\n        case \"SHA512_256\":\n        case 6:\n          message.hash = 6;\n          break;\n      }\n\n      if (object.prefix != null) if (typeof object.prefix === \"string\") $util.base64.decode(object.prefix, message.prefix = $util.newBuffer($util.base64.length(object.prefix)), 0);else if (object.prefix.length) message.prefix = object.prefix;\n      if (object.suffix != null) if (typeof object.suffix === \"string\") $util.base64.decode(object.suffix, message.suffix = $util.newBuffer($util.base64.length(object.suffix)), 0);else if (object.suffix.length) message.suffix = object.suffix;\n      return message;\n    };\n    /**\n     * Creates a plain object from an InnerOp message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof ics23.InnerOp\n     * @static\n     * @param {ics23.InnerOp} message InnerOp\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    InnerOp.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n\n      if (options.defaults) {\n        object.hash = options.enums === String ? \"NO_HASH\" : 0;\n        if (options.bytes === String) object.prefix = \"\";else {\n          object.prefix = [];\n          if (options.bytes !== Array) object.prefix = $util.newBuffer(object.prefix);\n        }\n        if (options.bytes === String) object.suffix = \"\";else {\n          object.suffix = [];\n          if (options.bytes !== Array) object.suffix = $util.newBuffer(object.suffix);\n        }\n      }\n\n      if (message.hash != null && message.hasOwnProperty(\"hash\")) object.hash = options.enums === String ? $root.ics23.HashOp[message.hash] : message.hash;\n      if (message.prefix != null && message.hasOwnProperty(\"prefix\")) object.prefix = options.bytes === String ? $util.base64.encode(message.prefix, 0, message.prefix.length) : options.bytes === Array ? Array.prototype.slice.call(message.prefix) : message.prefix;\n      if (message.suffix != null && message.hasOwnProperty(\"suffix\")) object.suffix = options.bytes === String ? $util.base64.encode(message.suffix, 0, message.suffix.length) : options.bytes === Array ? Array.prototype.slice.call(message.suffix) : message.suffix;\n      return object;\n    };\n    /**\n     * Converts this InnerOp to JSON.\n     * @function toJSON\n     * @memberof ics23.InnerOp\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    InnerOp.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return InnerOp;\n  }();\n\n  ics23.ProofSpec = function () {\n    /**\n     * Properties of a ProofSpec.\n     * @memberof ics23\n     * @interface IProofSpec\n     * @property {ics23.ILeafOp|null} [leafSpec] ProofSpec leafSpec\n     * @property {ics23.IInnerSpec|null} [innerSpec] ProofSpec innerSpec\n     * @property {number|null} [maxDepth] ProofSpec maxDepth\n     * @property {number|null} [minDepth] ProofSpec minDepth\n     */\n\n    /**\n     * Constructs a new ProofSpec.\n     * @memberof ics23\n     * @classdesc ProofSpec defines what the expected parameters are for a given proof type.\n     * This can be stored in the client and used to validate any incoming proofs.\n     * \n     * verify(ProofSpec, Proof) -> Proof | Error\n     * \n     * As demonstrated in tests, if we don't fix the algorithm used to calculate the\n     * LeafHash for a given tree, there are many possible key-value pairs that can\n     * generate a given hash (by interpretting the preimage differently).\n     * We need this for proper security, requires client knows a priori what\n     * tree format server uses. But not in code, rather a configuration object.\n     * @implements IProofSpec\n     * @constructor\n     * @param {ics23.IProofSpec=} [properties] Properties to set\n     */\n    function ProofSpec(properties) {\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n    }\n    /**\n     * ProofSpec leafSpec.\n     * @member {ics23.ILeafOp|null|undefined} leafSpec\n     * @memberof ics23.ProofSpec\n     * @instance\n     */\n\n\n    ProofSpec.prototype.leafSpec = null;\n    /**\n     * ProofSpec innerSpec.\n     * @member {ics23.IInnerSpec|null|undefined} innerSpec\n     * @memberof ics23.ProofSpec\n     * @instance\n     */\n\n    ProofSpec.prototype.innerSpec = null;\n    /**\n     * ProofSpec maxDepth.\n     * @member {number} maxDepth\n     * @memberof ics23.ProofSpec\n     * @instance\n     */\n\n    ProofSpec.prototype.maxDepth = 0;\n    /**\n     * ProofSpec minDepth.\n     * @member {number} minDepth\n     * @memberof ics23.ProofSpec\n     * @instance\n     */\n\n    ProofSpec.prototype.minDepth = 0;\n    /**\n     * Creates a new ProofSpec instance using the specified properties.\n     * @function create\n     * @memberof ics23.ProofSpec\n     * @static\n     * @param {ics23.IProofSpec=} [properties] Properties to set\n     * @returns {ics23.ProofSpec} ProofSpec instance\n     */\n\n    ProofSpec.create = function create(properties) {\n      return new ProofSpec(properties);\n    };\n    /**\n     * Encodes the specified ProofSpec message. Does not implicitly {@link ics23.ProofSpec.verify|verify} messages.\n     * @function encode\n     * @memberof ics23.ProofSpec\n     * @static\n     * @param {ics23.IProofSpec} message ProofSpec message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    ProofSpec.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.leafSpec != null && message.hasOwnProperty(\"leafSpec\")) $root.ics23.LeafOp.encode(message.leafSpec, writer.uint32(\n      /* id 1, wireType 2 =*/\n      10).fork()).ldelim();\n      if (message.innerSpec != null && message.hasOwnProperty(\"innerSpec\")) $root.ics23.InnerSpec.encode(message.innerSpec, writer.uint32(\n      /* id 2, wireType 2 =*/\n      18).fork()).ldelim();\n      if (message.maxDepth != null && message.hasOwnProperty(\"maxDepth\")) writer.uint32(\n      /* id 3, wireType 0 =*/\n      24).int32(message.maxDepth);\n      if (message.minDepth != null && message.hasOwnProperty(\"minDepth\")) writer.uint32(\n      /* id 4, wireType 0 =*/\n      32).int32(message.minDepth);\n      return writer;\n    };\n    /**\n     * Encodes the specified ProofSpec message, length delimited. Does not implicitly {@link ics23.ProofSpec.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof ics23.ProofSpec\n     * @static\n     * @param {ics23.IProofSpec} message ProofSpec message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    ProofSpec.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes a ProofSpec message from the specified reader or buffer.\n     * @function decode\n     * @memberof ics23.ProofSpec\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ics23.ProofSpec} ProofSpec\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    ProofSpec.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.ics23.ProofSpec();\n\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.leafSpec = $root.ics23.LeafOp.decode(reader, reader.uint32());\n            break;\n\n          case 2:\n            message.innerSpec = $root.ics23.InnerSpec.decode(reader, reader.uint32());\n            break;\n\n          case 3:\n            message.maxDepth = reader.int32();\n            break;\n\n          case 4:\n            message.minDepth = reader.int32();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Decodes a ProofSpec message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof ics23.ProofSpec\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {ics23.ProofSpec} ProofSpec\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    ProofSpec.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies a ProofSpec message.\n     * @function verify\n     * @memberof ics23.ProofSpec\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n\n\n    ProofSpec.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n      if (message.leafSpec != null && message.hasOwnProperty(\"leafSpec\")) {\n        var error = $root.ics23.LeafOp.verify(message.leafSpec);\n        if (error) return \"leafSpec.\" + error;\n      }\n\n      if (message.innerSpec != null && message.hasOwnProperty(\"innerSpec\")) {\n        var error = $root.ics23.InnerSpec.verify(message.innerSpec);\n        if (error) return \"innerSpec.\" + error;\n      }\n\n      if (message.maxDepth != null && message.hasOwnProperty(\"maxDepth\")) if (!$util.isInteger(message.maxDepth)) return \"maxDepth: integer expected\";\n      if (message.minDepth != null && message.hasOwnProperty(\"minDepth\")) if (!$util.isInteger(message.minDepth)) return \"minDepth: integer expected\";\n      return null;\n    };\n    /**\n     * Creates a ProofSpec message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof ics23.ProofSpec\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {ics23.ProofSpec} ProofSpec\n     */\n\n\n    ProofSpec.fromObject = function fromObject(object) {\n      if (object instanceof $root.ics23.ProofSpec) return object;\n      var message = new $root.ics23.ProofSpec();\n\n      if (object.leafSpec != null) {\n        if (typeof object.leafSpec !== \"object\") throw TypeError(\".ics23.ProofSpec.leafSpec: object expected\");\n        message.leafSpec = $root.ics23.LeafOp.fromObject(object.leafSpec);\n      }\n\n      if (object.innerSpec != null) {\n        if (typeof object.innerSpec !== \"object\") throw TypeError(\".ics23.ProofSpec.innerSpec: object expected\");\n        message.innerSpec = $root.ics23.InnerSpec.fromObject(object.innerSpec);\n      }\n\n      if (object.maxDepth != null) message.maxDepth = object.maxDepth | 0;\n      if (object.minDepth != null) message.minDepth = object.minDepth | 0;\n      return message;\n    };\n    /**\n     * Creates a plain object from a ProofSpec message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof ics23.ProofSpec\n     * @static\n     * @param {ics23.ProofSpec} message ProofSpec\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    ProofSpec.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n\n      if (options.defaults) {\n        object.leafSpec = null;\n        object.innerSpec = null;\n        object.maxDepth = 0;\n        object.minDepth = 0;\n      }\n\n      if (message.leafSpec != null && message.hasOwnProperty(\"leafSpec\")) object.leafSpec = $root.ics23.LeafOp.toObject(message.leafSpec, options);\n      if (message.innerSpec != null && message.hasOwnProperty(\"innerSpec\")) object.innerSpec = $root.ics23.InnerSpec.toObject(message.innerSpec, options);\n      if (message.maxDepth != null && message.hasOwnProperty(\"maxDepth\")) object.maxDepth = message.maxDepth;\n      if (message.minDepth != null && message.hasOwnProperty(\"minDepth\")) object.minDepth = message.minDepth;\n      return object;\n    };\n    /**\n     * Converts this ProofSpec to JSON.\n     * @function toJSON\n     * @memberof ics23.ProofSpec\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    ProofSpec.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return ProofSpec;\n  }();\n\n  ics23.InnerSpec = function () {\n    /**\n     * Properties of an InnerSpec.\n     * @memberof ics23\n     * @interface IInnerSpec\n     * @property {Array.<number>|null} [childOrder] InnerSpec childOrder\n     * @property {number|null} [childSize] InnerSpec childSize\n     * @property {number|null} [minPrefixLength] InnerSpec minPrefixLength\n     * @property {number|null} [maxPrefixLength] InnerSpec maxPrefixLength\n     * @property {Uint8Array|null} [emptyChild] InnerSpec emptyChild\n     * @property {ics23.HashOp|null} [hash] InnerSpec hash\n     */\n\n    /**\n     * Constructs a new InnerSpec.\n     * @memberof ics23\n     * @classdesc Represents an InnerSpec.\n     * @implements IInnerSpec\n     * @constructor\n     * @param {ics23.IInnerSpec=} [properties] Properties to set\n     */\n    function InnerSpec(properties) {\n      this.childOrder = [];\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n    }\n    /**\n     * InnerSpec childOrder.\n     * @member {Array.<number>} childOrder\n     * @memberof ics23.InnerSpec\n     * @instance\n     */\n\n\n    InnerSpec.prototype.childOrder = $util.emptyArray;\n    /**\n     * InnerSpec childSize.\n     * @member {number} childSize\n     * @memberof ics23.InnerSpec\n     * @instance\n     */\n\n    InnerSpec.prototype.childSize = 0;\n    /**\n     * InnerSpec minPrefixLength.\n     * @member {number} minPrefixLength\n     * @memberof ics23.InnerSpec\n     * @instance\n     */\n\n    InnerSpec.prototype.minPrefixLength = 0;\n    /**\n     * InnerSpec maxPrefixLength.\n     * @member {number} maxPrefixLength\n     * @memberof ics23.InnerSpec\n     * @instance\n     */\n\n    InnerSpec.prototype.maxPrefixLength = 0;\n    /**\n     * InnerSpec emptyChild.\n     * @member {Uint8Array} emptyChild\n     * @memberof ics23.InnerSpec\n     * @instance\n     */\n\n    InnerSpec.prototype.emptyChild = $util.newBuffer([]);\n    /**\n     * InnerSpec hash.\n     * @member {ics23.HashOp} hash\n     * @memberof ics23.InnerSpec\n     * @instance\n     */\n\n    InnerSpec.prototype.hash = 0;\n    /**\n     * Creates a new InnerSpec instance using the specified properties.\n     * @function create\n     * @memberof ics23.InnerSpec\n     * @static\n     * @param {ics23.IInnerSpec=} [properties] Properties to set\n     * @returns {ics23.InnerSpec} InnerSpec instance\n     */\n\n    InnerSpec.create = function create(properties) {\n      return new InnerSpec(properties);\n    };\n    /**\n     * Encodes the specified InnerSpec message. Does not implicitly {@link ics23.InnerSpec.verify|verify} messages.\n     * @function encode\n     * @memberof ics23.InnerSpec\n     * @static\n     * @param {ics23.IInnerSpec} message InnerSpec message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    InnerSpec.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n\n      if (message.childOrder != null && message.childOrder.length) {\n        writer.uint32(\n        /* id 1, wireType 2 =*/\n        10).fork();\n\n        for (var i = 0; i < message.childOrder.length; ++i) {\n          writer.int32(message.childOrder[i]);\n        }\n\n        writer.ldelim();\n      }\n\n      if (message.childSize != null && message.hasOwnProperty(\"childSize\")) writer.uint32(\n      /* id 2, wireType 0 =*/\n      16).int32(message.childSize);\n      if (message.minPrefixLength != null && message.hasOwnProperty(\"minPrefixLength\")) writer.uint32(\n      /* id 3, wireType 0 =*/\n      24).int32(message.minPrefixLength);\n      if (message.maxPrefixLength != null && message.hasOwnProperty(\"maxPrefixLength\")) writer.uint32(\n      /* id 4, wireType 0 =*/\n      32).int32(message.maxPrefixLength);\n      if (message.emptyChild != null && message.hasOwnProperty(\"emptyChild\")) writer.uint32(\n      /* id 5, wireType 2 =*/\n      42).bytes(message.emptyChild);\n      if (message.hash != null && message.hasOwnProperty(\"hash\")) writer.uint32(\n      /* id 6, wireType 0 =*/\n      48).int32(message.hash);\n      return writer;\n    };\n    /**\n     * Encodes the specified InnerSpec message, length delimited. Does not implicitly {@link ics23.InnerSpec.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof ics23.InnerSpec\n     * @static\n     * @param {ics23.IInnerSpec} message InnerSpec message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    InnerSpec.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes an InnerSpec message from the specified reader or buffer.\n     * @function decode\n     * @memberof ics23.InnerSpec\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ics23.InnerSpec} InnerSpec\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    InnerSpec.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.ics23.InnerSpec();\n\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            if (!(message.childOrder && message.childOrder.length)) message.childOrder = [];\n\n            if ((tag & 7) === 2) {\n              var end2 = reader.uint32() + reader.pos;\n\n              while (reader.pos < end2) {\n                message.childOrder.push(reader.int32());\n              }\n            } else message.childOrder.push(reader.int32());\n\n            break;\n\n          case 2:\n            message.childSize = reader.int32();\n            break;\n\n          case 3:\n            message.minPrefixLength = reader.int32();\n            break;\n\n          case 4:\n            message.maxPrefixLength = reader.int32();\n            break;\n\n          case 5:\n            message.emptyChild = reader.bytes();\n            break;\n\n          case 6:\n            message.hash = reader.int32();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Decodes an InnerSpec message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof ics23.InnerSpec\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {ics23.InnerSpec} InnerSpec\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    InnerSpec.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies an InnerSpec message.\n     * @function verify\n     * @memberof ics23.InnerSpec\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n\n\n    InnerSpec.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n      if (message.childOrder != null && message.hasOwnProperty(\"childOrder\")) {\n        if (!Array.isArray(message.childOrder)) return \"childOrder: array expected\";\n\n        for (var i = 0; i < message.childOrder.length; ++i) {\n          if (!$util.isInteger(message.childOrder[i])) return \"childOrder: integer[] expected\";\n        }\n      }\n\n      if (message.childSize != null && message.hasOwnProperty(\"childSize\")) if (!$util.isInteger(message.childSize)) return \"childSize: integer expected\";\n      if (message.minPrefixLength != null && message.hasOwnProperty(\"minPrefixLength\")) if (!$util.isInteger(message.minPrefixLength)) return \"minPrefixLength: integer expected\";\n      if (message.maxPrefixLength != null && message.hasOwnProperty(\"maxPrefixLength\")) if (!$util.isInteger(message.maxPrefixLength)) return \"maxPrefixLength: integer expected\";\n      if (message.emptyChild != null && message.hasOwnProperty(\"emptyChild\")) if (!(message.emptyChild && typeof message.emptyChild.length === \"number\" || $util.isString(message.emptyChild))) return \"emptyChild: buffer expected\";\n      if (message.hash != null && message.hasOwnProperty(\"hash\")) switch (message.hash) {\n        default:\n          return \"hash: enum value expected\";\n\n        case 0:\n        case 1:\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n          break;\n      }\n      return null;\n    };\n    /**\n     * Creates an InnerSpec message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof ics23.InnerSpec\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {ics23.InnerSpec} InnerSpec\n     */\n\n\n    InnerSpec.fromObject = function fromObject(object) {\n      if (object instanceof $root.ics23.InnerSpec) return object;\n      var message = new $root.ics23.InnerSpec();\n\n      if (object.childOrder) {\n        if (!Array.isArray(object.childOrder)) throw TypeError(\".ics23.InnerSpec.childOrder: array expected\");\n        message.childOrder = [];\n\n        for (var i = 0; i < object.childOrder.length; ++i) {\n          message.childOrder[i] = object.childOrder[i] | 0;\n        }\n      }\n\n      if (object.childSize != null) message.childSize = object.childSize | 0;\n      if (object.minPrefixLength != null) message.minPrefixLength = object.minPrefixLength | 0;\n      if (object.maxPrefixLength != null) message.maxPrefixLength = object.maxPrefixLength | 0;\n      if (object.emptyChild != null) if (typeof object.emptyChild === \"string\") $util.base64.decode(object.emptyChild, message.emptyChild = $util.newBuffer($util.base64.length(object.emptyChild)), 0);else if (object.emptyChild.length) message.emptyChild = object.emptyChild;\n\n      switch (object.hash) {\n        case \"NO_HASH\":\n        case 0:\n          message.hash = 0;\n          break;\n\n        case \"SHA256\":\n        case 1:\n          message.hash = 1;\n          break;\n\n        case \"SHA512\":\n        case 2:\n          message.hash = 2;\n          break;\n\n        case \"KECCAK\":\n        case 3:\n          message.hash = 3;\n          break;\n\n        case \"RIPEMD160\":\n        case 4:\n          message.hash = 4;\n          break;\n\n        case \"BITCOIN\":\n        case 5:\n          message.hash = 5;\n          break;\n\n        case \"SHA512_256\":\n        case 6:\n          message.hash = 6;\n          break;\n      }\n\n      return message;\n    };\n    /**\n     * Creates a plain object from an InnerSpec message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof ics23.InnerSpec\n     * @static\n     * @param {ics23.InnerSpec} message InnerSpec\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    InnerSpec.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n      if (options.arrays || options.defaults) object.childOrder = [];\n\n      if (options.defaults) {\n        object.childSize = 0;\n        object.minPrefixLength = 0;\n        object.maxPrefixLength = 0;\n        if (options.bytes === String) object.emptyChild = \"\";else {\n          object.emptyChild = [];\n          if (options.bytes !== Array) object.emptyChild = $util.newBuffer(object.emptyChild);\n        }\n        object.hash = options.enums === String ? \"NO_HASH\" : 0;\n      }\n\n      if (message.childOrder && message.childOrder.length) {\n        object.childOrder = [];\n\n        for (var j = 0; j < message.childOrder.length; ++j) {\n          object.childOrder[j] = message.childOrder[j];\n        }\n      }\n\n      if (message.childSize != null && message.hasOwnProperty(\"childSize\")) object.childSize = message.childSize;\n      if (message.minPrefixLength != null && message.hasOwnProperty(\"minPrefixLength\")) object.minPrefixLength = message.minPrefixLength;\n      if (message.maxPrefixLength != null && message.hasOwnProperty(\"maxPrefixLength\")) object.maxPrefixLength = message.maxPrefixLength;\n      if (message.emptyChild != null && message.hasOwnProperty(\"emptyChild\")) object.emptyChild = options.bytes === String ? $util.base64.encode(message.emptyChild, 0, message.emptyChild.length) : options.bytes === Array ? Array.prototype.slice.call(message.emptyChild) : message.emptyChild;\n      if (message.hash != null && message.hasOwnProperty(\"hash\")) object.hash = options.enums === String ? $root.ics23.HashOp[message.hash] : message.hash;\n      return object;\n    };\n    /**\n     * Converts this InnerSpec to JSON.\n     * @function toJSON\n     * @memberof ics23.InnerSpec\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    InnerSpec.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return InnerSpec;\n  }();\n\n  ics23.BatchProof = function () {\n    /**\n     * Properties of a BatchProof.\n     * @memberof ics23\n     * @interface IBatchProof\n     * @property {Array.<ics23.IBatchEntry>|null} [entries] BatchProof entries\n     */\n\n    /**\n     * Constructs a new BatchProof.\n     * @memberof ics23\n     * @classdesc Represents a BatchProof.\n     * @implements IBatchProof\n     * @constructor\n     * @param {ics23.IBatchProof=} [properties] Properties to set\n     */\n    function BatchProof(properties) {\n      this.entries = [];\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n    }\n    /**\n     * BatchProof entries.\n     * @member {Array.<ics23.IBatchEntry>} entries\n     * @memberof ics23.BatchProof\n     * @instance\n     */\n\n\n    BatchProof.prototype.entries = $util.emptyArray;\n    /**\n     * Creates a new BatchProof instance using the specified properties.\n     * @function create\n     * @memberof ics23.BatchProof\n     * @static\n     * @param {ics23.IBatchProof=} [properties] Properties to set\n     * @returns {ics23.BatchProof} BatchProof instance\n     */\n\n    BatchProof.create = function create(properties) {\n      return new BatchProof(properties);\n    };\n    /**\n     * Encodes the specified BatchProof message. Does not implicitly {@link ics23.BatchProof.verify|verify} messages.\n     * @function encode\n     * @memberof ics23.BatchProof\n     * @static\n     * @param {ics23.IBatchProof} message BatchProof message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    BatchProof.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.entries != null && message.entries.length) for (var i = 0; i < message.entries.length; ++i) {\n        $root.ics23.BatchEntry.encode(message.entries[i], writer.uint32(\n        /* id 1, wireType 2 =*/\n        10).fork()).ldelim();\n      }\n      return writer;\n    };\n    /**\n     * Encodes the specified BatchProof message, length delimited. Does not implicitly {@link ics23.BatchProof.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof ics23.BatchProof\n     * @static\n     * @param {ics23.IBatchProof} message BatchProof message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    BatchProof.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes a BatchProof message from the specified reader or buffer.\n     * @function decode\n     * @memberof ics23.BatchProof\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ics23.BatchProof} BatchProof\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    BatchProof.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.ics23.BatchProof();\n\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            if (!(message.entries && message.entries.length)) message.entries = [];\n            message.entries.push($root.ics23.BatchEntry.decode(reader, reader.uint32()));\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Decodes a BatchProof message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof ics23.BatchProof\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {ics23.BatchProof} BatchProof\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    BatchProof.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies a BatchProof message.\n     * @function verify\n     * @memberof ics23.BatchProof\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n\n\n    BatchProof.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n      if (message.entries != null && message.hasOwnProperty(\"entries\")) {\n        if (!Array.isArray(message.entries)) return \"entries: array expected\";\n\n        for (var i = 0; i < message.entries.length; ++i) {\n          var error = $root.ics23.BatchEntry.verify(message.entries[i]);\n          if (error) return \"entries.\" + error;\n        }\n      }\n\n      return null;\n    };\n    /**\n     * Creates a BatchProof message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof ics23.BatchProof\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {ics23.BatchProof} BatchProof\n     */\n\n\n    BatchProof.fromObject = function fromObject(object) {\n      if (object instanceof $root.ics23.BatchProof) return object;\n      var message = new $root.ics23.BatchProof();\n\n      if (object.entries) {\n        if (!Array.isArray(object.entries)) throw TypeError(\".ics23.BatchProof.entries: array expected\");\n        message.entries = [];\n\n        for (var i = 0; i < object.entries.length; ++i) {\n          if (typeof object.entries[i] !== \"object\") throw TypeError(\".ics23.BatchProof.entries: object expected\");\n          message.entries[i] = $root.ics23.BatchEntry.fromObject(object.entries[i]);\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Creates a plain object from a BatchProof message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof ics23.BatchProof\n     * @static\n     * @param {ics23.BatchProof} message BatchProof\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    BatchProof.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n      if (options.arrays || options.defaults) object.entries = [];\n\n      if (message.entries && message.entries.length) {\n        object.entries = [];\n\n        for (var j = 0; j < message.entries.length; ++j) {\n          object.entries[j] = $root.ics23.BatchEntry.toObject(message.entries[j], options);\n        }\n      }\n\n      return object;\n    };\n    /**\n     * Converts this BatchProof to JSON.\n     * @function toJSON\n     * @memberof ics23.BatchProof\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    BatchProof.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return BatchProof;\n  }();\n\n  ics23.BatchEntry = function () {\n    /**\n     * Properties of a BatchEntry.\n     * @memberof ics23\n     * @interface IBatchEntry\n     * @property {ics23.IExistenceProof|null} [exist] BatchEntry exist\n     * @property {ics23.INonExistenceProof|null} [nonexist] BatchEntry nonexist\n     */\n\n    /**\n     * Constructs a new BatchEntry.\n     * @memberof ics23\n     * @classdesc Represents a BatchEntry.\n     * @implements IBatchEntry\n     * @constructor\n     * @param {ics23.IBatchEntry=} [properties] Properties to set\n     */\n    function BatchEntry(properties) {\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n    }\n    /**\n     * BatchEntry exist.\n     * @member {ics23.IExistenceProof|null|undefined} exist\n     * @memberof ics23.BatchEntry\n     * @instance\n     */\n\n\n    BatchEntry.prototype.exist = null;\n    /**\n     * BatchEntry nonexist.\n     * @member {ics23.INonExistenceProof|null|undefined} nonexist\n     * @memberof ics23.BatchEntry\n     * @instance\n     */\n\n    BatchEntry.prototype.nonexist = null; // OneOf field names bound to virtual getters and setters\n\n    var $oneOfFields;\n    /**\n     * BatchEntry proof.\n     * @member {\"exist\"|\"nonexist\"|undefined} proof\n     * @memberof ics23.BatchEntry\n     * @instance\n     */\n\n    Object.defineProperty(BatchEntry.prototype, \"proof\", {\n      get: $util.oneOfGetter($oneOfFields = [\"exist\", \"nonexist\"]),\n      set: $util.oneOfSetter($oneOfFields)\n    });\n    /**\n     * Creates a new BatchEntry instance using the specified properties.\n     * @function create\n     * @memberof ics23.BatchEntry\n     * @static\n     * @param {ics23.IBatchEntry=} [properties] Properties to set\n     * @returns {ics23.BatchEntry} BatchEntry instance\n     */\n\n    BatchEntry.create = function create(properties) {\n      return new BatchEntry(properties);\n    };\n    /**\n     * Encodes the specified BatchEntry message. Does not implicitly {@link ics23.BatchEntry.verify|verify} messages.\n     * @function encode\n     * @memberof ics23.BatchEntry\n     * @static\n     * @param {ics23.IBatchEntry} message BatchEntry message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    BatchEntry.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.exist != null && message.hasOwnProperty(\"exist\")) $root.ics23.ExistenceProof.encode(message.exist, writer.uint32(\n      /* id 1, wireType 2 =*/\n      10).fork()).ldelim();\n      if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) $root.ics23.NonExistenceProof.encode(message.nonexist, writer.uint32(\n      /* id 2, wireType 2 =*/\n      18).fork()).ldelim();\n      return writer;\n    };\n    /**\n     * Encodes the specified BatchEntry message, length delimited. Does not implicitly {@link ics23.BatchEntry.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof ics23.BatchEntry\n     * @static\n     * @param {ics23.IBatchEntry} message BatchEntry message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    BatchEntry.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes a BatchEntry message from the specified reader or buffer.\n     * @function decode\n     * @memberof ics23.BatchEntry\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ics23.BatchEntry} BatchEntry\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    BatchEntry.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.ics23.BatchEntry();\n\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.exist = $root.ics23.ExistenceProof.decode(reader, reader.uint32());\n            break;\n\n          case 2:\n            message.nonexist = $root.ics23.NonExistenceProof.decode(reader, reader.uint32());\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Decodes a BatchEntry message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof ics23.BatchEntry\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {ics23.BatchEntry} BatchEntry\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    BatchEntry.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies a BatchEntry message.\n     * @function verify\n     * @memberof ics23.BatchEntry\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n\n\n    BatchEntry.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n      var properties = {};\n\n      if (message.exist != null && message.hasOwnProperty(\"exist\")) {\n        properties.proof = 1;\n        {\n          var error = $root.ics23.ExistenceProof.verify(message.exist);\n          if (error) return \"exist.\" + error;\n        }\n      }\n\n      if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) {\n        if (properties.proof === 1) return \"proof: multiple values\";\n        properties.proof = 1;\n        {\n          var error = $root.ics23.NonExistenceProof.verify(message.nonexist);\n          if (error) return \"nonexist.\" + error;\n        }\n      }\n\n      return null;\n    };\n    /**\n     * Creates a BatchEntry message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof ics23.BatchEntry\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {ics23.BatchEntry} BatchEntry\n     */\n\n\n    BatchEntry.fromObject = function fromObject(object) {\n      if (object instanceof $root.ics23.BatchEntry) return object;\n      var message = new $root.ics23.BatchEntry();\n\n      if (object.exist != null) {\n        if (typeof object.exist !== \"object\") throw TypeError(\".ics23.BatchEntry.exist: object expected\");\n        message.exist = $root.ics23.ExistenceProof.fromObject(object.exist);\n      }\n\n      if (object.nonexist != null) {\n        if (typeof object.nonexist !== \"object\") throw TypeError(\".ics23.BatchEntry.nonexist: object expected\");\n        message.nonexist = $root.ics23.NonExistenceProof.fromObject(object.nonexist);\n      }\n\n      return message;\n    };\n    /**\n     * Creates a plain object from a BatchEntry message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof ics23.BatchEntry\n     * @static\n     * @param {ics23.BatchEntry} message BatchEntry\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    BatchEntry.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n\n      if (message.exist != null && message.hasOwnProperty(\"exist\")) {\n        object.exist = $root.ics23.ExistenceProof.toObject(message.exist, options);\n        if (options.oneofs) object.proof = \"exist\";\n      }\n\n      if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) {\n        object.nonexist = $root.ics23.NonExistenceProof.toObject(message.nonexist, options);\n        if (options.oneofs) object.proof = \"nonexist\";\n      }\n\n      return object;\n    };\n    /**\n     * Converts this BatchEntry to JSON.\n     * @function toJSON\n     * @memberof ics23.BatchEntry\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    BatchEntry.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return BatchEntry;\n  }();\n\n  ics23.CompressedBatchProof = function () {\n    /**\n     * Properties of a CompressedBatchProof.\n     * @memberof ics23\n     * @interface ICompressedBatchProof\n     * @property {Array.<ics23.ICompressedBatchEntry>|null} [entries] CompressedBatchProof entries\n     * @property {Array.<ics23.IInnerOp>|null} [lookupInners] CompressedBatchProof lookupInners\n     */\n\n    /**\n     * Constructs a new CompressedBatchProof.\n     * @memberof ics23\n     * @classdesc Represents a CompressedBatchProof.\n     * @implements ICompressedBatchProof\n     * @constructor\n     * @param {ics23.ICompressedBatchProof=} [properties] Properties to set\n     */\n    function CompressedBatchProof(properties) {\n      this.entries = [];\n      this.lookupInners = [];\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n    }\n    /**\n     * CompressedBatchProof entries.\n     * @member {Array.<ics23.ICompressedBatchEntry>} entries\n     * @memberof ics23.CompressedBatchProof\n     * @instance\n     */\n\n\n    CompressedBatchProof.prototype.entries = $util.emptyArray;\n    /**\n     * CompressedBatchProof lookupInners.\n     * @member {Array.<ics23.IInnerOp>} lookupInners\n     * @memberof ics23.CompressedBatchProof\n     * @instance\n     */\n\n    CompressedBatchProof.prototype.lookupInners = $util.emptyArray;\n    /**\n     * Creates a new CompressedBatchProof instance using the specified properties.\n     * @function create\n     * @memberof ics23.CompressedBatchProof\n     * @static\n     * @param {ics23.ICompressedBatchProof=} [properties] Properties to set\n     * @returns {ics23.CompressedBatchProof} CompressedBatchProof instance\n     */\n\n    CompressedBatchProof.create = function create(properties) {\n      return new CompressedBatchProof(properties);\n    };\n    /**\n     * Encodes the specified CompressedBatchProof message. Does not implicitly {@link ics23.CompressedBatchProof.verify|verify} messages.\n     * @function encode\n     * @memberof ics23.CompressedBatchProof\n     * @static\n     * @param {ics23.ICompressedBatchProof} message CompressedBatchProof message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    CompressedBatchProof.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.entries != null && message.entries.length) for (var i = 0; i < message.entries.length; ++i) {\n        $root.ics23.CompressedBatchEntry.encode(message.entries[i], writer.uint32(\n        /* id 1, wireType 2 =*/\n        10).fork()).ldelim();\n      }\n      if (message.lookupInners != null && message.lookupInners.length) for (var i = 0; i < message.lookupInners.length; ++i) {\n        $root.ics23.InnerOp.encode(message.lookupInners[i], writer.uint32(\n        /* id 2, wireType 2 =*/\n        18).fork()).ldelim();\n      }\n      return writer;\n    };\n    /**\n     * Encodes the specified CompressedBatchProof message, length delimited. Does not implicitly {@link ics23.CompressedBatchProof.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof ics23.CompressedBatchProof\n     * @static\n     * @param {ics23.ICompressedBatchProof} message CompressedBatchProof message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    CompressedBatchProof.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes a CompressedBatchProof message from the specified reader or buffer.\n     * @function decode\n     * @memberof ics23.CompressedBatchProof\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ics23.CompressedBatchProof} CompressedBatchProof\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    CompressedBatchProof.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.ics23.CompressedBatchProof();\n\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            if (!(message.entries && message.entries.length)) message.entries = [];\n            message.entries.push($root.ics23.CompressedBatchEntry.decode(reader, reader.uint32()));\n            break;\n\n          case 2:\n            if (!(message.lookupInners && message.lookupInners.length)) message.lookupInners = [];\n            message.lookupInners.push($root.ics23.InnerOp.decode(reader, reader.uint32()));\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Decodes a CompressedBatchProof message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof ics23.CompressedBatchProof\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {ics23.CompressedBatchProof} CompressedBatchProof\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    CompressedBatchProof.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies a CompressedBatchProof message.\n     * @function verify\n     * @memberof ics23.CompressedBatchProof\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n\n\n    CompressedBatchProof.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n      if (message.entries != null && message.hasOwnProperty(\"entries\")) {\n        if (!Array.isArray(message.entries)) return \"entries: array expected\";\n\n        for (var i = 0; i < message.entries.length; ++i) {\n          var error = $root.ics23.CompressedBatchEntry.verify(message.entries[i]);\n          if (error) return \"entries.\" + error;\n        }\n      }\n\n      if (message.lookupInners != null && message.hasOwnProperty(\"lookupInners\")) {\n        if (!Array.isArray(message.lookupInners)) return \"lookupInners: array expected\";\n\n        for (var i = 0; i < message.lookupInners.length; ++i) {\n          var error = $root.ics23.InnerOp.verify(message.lookupInners[i]);\n          if (error) return \"lookupInners.\" + error;\n        }\n      }\n\n      return null;\n    };\n    /**\n     * Creates a CompressedBatchProof message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof ics23.CompressedBatchProof\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {ics23.CompressedBatchProof} CompressedBatchProof\n     */\n\n\n    CompressedBatchProof.fromObject = function fromObject(object) {\n      if (object instanceof $root.ics23.CompressedBatchProof) return object;\n      var message = new $root.ics23.CompressedBatchProof();\n\n      if (object.entries) {\n        if (!Array.isArray(object.entries)) throw TypeError(\".ics23.CompressedBatchProof.entries: array expected\");\n        message.entries = [];\n\n        for (var i = 0; i < object.entries.length; ++i) {\n          if (typeof object.entries[i] !== \"object\") throw TypeError(\".ics23.CompressedBatchProof.entries: object expected\");\n          message.entries[i] = $root.ics23.CompressedBatchEntry.fromObject(object.entries[i]);\n        }\n      }\n\n      if (object.lookupInners) {\n        if (!Array.isArray(object.lookupInners)) throw TypeError(\".ics23.CompressedBatchProof.lookupInners: array expected\");\n        message.lookupInners = [];\n\n        for (var i = 0; i < object.lookupInners.length; ++i) {\n          if (typeof object.lookupInners[i] !== \"object\") throw TypeError(\".ics23.CompressedBatchProof.lookupInners: object expected\");\n          message.lookupInners[i] = $root.ics23.InnerOp.fromObject(object.lookupInners[i]);\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Creates a plain object from a CompressedBatchProof message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof ics23.CompressedBatchProof\n     * @static\n     * @param {ics23.CompressedBatchProof} message CompressedBatchProof\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    CompressedBatchProof.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n\n      if (options.arrays || options.defaults) {\n        object.entries = [];\n        object.lookupInners = [];\n      }\n\n      if (message.entries && message.entries.length) {\n        object.entries = [];\n\n        for (var j = 0; j < message.entries.length; ++j) {\n          object.entries[j] = $root.ics23.CompressedBatchEntry.toObject(message.entries[j], options);\n        }\n      }\n\n      if (message.lookupInners && message.lookupInners.length) {\n        object.lookupInners = [];\n\n        for (var j = 0; j < message.lookupInners.length; ++j) {\n          object.lookupInners[j] = $root.ics23.InnerOp.toObject(message.lookupInners[j], options);\n        }\n      }\n\n      return object;\n    };\n    /**\n     * Converts this CompressedBatchProof to JSON.\n     * @function toJSON\n     * @memberof ics23.CompressedBatchProof\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    CompressedBatchProof.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return CompressedBatchProof;\n  }();\n\n  ics23.CompressedBatchEntry = function () {\n    /**\n     * Properties of a CompressedBatchEntry.\n     * @memberof ics23\n     * @interface ICompressedBatchEntry\n     * @property {ics23.ICompressedExistenceProof|null} [exist] CompressedBatchEntry exist\n     * @property {ics23.ICompressedNonExistenceProof|null} [nonexist] CompressedBatchEntry nonexist\n     */\n\n    /**\n     * Constructs a new CompressedBatchEntry.\n     * @memberof ics23\n     * @classdesc Represents a CompressedBatchEntry.\n     * @implements ICompressedBatchEntry\n     * @constructor\n     * @param {ics23.ICompressedBatchEntry=} [properties] Properties to set\n     */\n    function CompressedBatchEntry(properties) {\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n    }\n    /**\n     * CompressedBatchEntry exist.\n     * @member {ics23.ICompressedExistenceProof|null|undefined} exist\n     * @memberof ics23.CompressedBatchEntry\n     * @instance\n     */\n\n\n    CompressedBatchEntry.prototype.exist = null;\n    /**\n     * CompressedBatchEntry nonexist.\n     * @member {ics23.ICompressedNonExistenceProof|null|undefined} nonexist\n     * @memberof ics23.CompressedBatchEntry\n     * @instance\n     */\n\n    CompressedBatchEntry.prototype.nonexist = null; // OneOf field names bound to virtual getters and setters\n\n    var $oneOfFields;\n    /**\n     * CompressedBatchEntry proof.\n     * @member {\"exist\"|\"nonexist\"|undefined} proof\n     * @memberof ics23.CompressedBatchEntry\n     * @instance\n     */\n\n    Object.defineProperty(CompressedBatchEntry.prototype, \"proof\", {\n      get: $util.oneOfGetter($oneOfFields = [\"exist\", \"nonexist\"]),\n      set: $util.oneOfSetter($oneOfFields)\n    });\n    /**\n     * Creates a new CompressedBatchEntry instance using the specified properties.\n     * @function create\n     * @memberof ics23.CompressedBatchEntry\n     * @static\n     * @param {ics23.ICompressedBatchEntry=} [properties] Properties to set\n     * @returns {ics23.CompressedBatchEntry} CompressedBatchEntry instance\n     */\n\n    CompressedBatchEntry.create = function create(properties) {\n      return new CompressedBatchEntry(properties);\n    };\n    /**\n     * Encodes the specified CompressedBatchEntry message. Does not implicitly {@link ics23.CompressedBatchEntry.verify|verify} messages.\n     * @function encode\n     * @memberof ics23.CompressedBatchEntry\n     * @static\n     * @param {ics23.ICompressedBatchEntry} message CompressedBatchEntry message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    CompressedBatchEntry.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.exist != null && message.hasOwnProperty(\"exist\")) $root.ics23.CompressedExistenceProof.encode(message.exist, writer.uint32(\n      /* id 1, wireType 2 =*/\n      10).fork()).ldelim();\n      if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) $root.ics23.CompressedNonExistenceProof.encode(message.nonexist, writer.uint32(\n      /* id 2, wireType 2 =*/\n      18).fork()).ldelim();\n      return writer;\n    };\n    /**\n     * Encodes the specified CompressedBatchEntry message, length delimited. Does not implicitly {@link ics23.CompressedBatchEntry.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof ics23.CompressedBatchEntry\n     * @static\n     * @param {ics23.ICompressedBatchEntry} message CompressedBatchEntry message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    CompressedBatchEntry.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes a CompressedBatchEntry message from the specified reader or buffer.\n     * @function decode\n     * @memberof ics23.CompressedBatchEntry\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ics23.CompressedBatchEntry} CompressedBatchEntry\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    CompressedBatchEntry.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.ics23.CompressedBatchEntry();\n\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.exist = $root.ics23.CompressedExistenceProof.decode(reader, reader.uint32());\n            break;\n\n          case 2:\n            message.nonexist = $root.ics23.CompressedNonExistenceProof.decode(reader, reader.uint32());\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Decodes a CompressedBatchEntry message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof ics23.CompressedBatchEntry\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {ics23.CompressedBatchEntry} CompressedBatchEntry\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    CompressedBatchEntry.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies a CompressedBatchEntry message.\n     * @function verify\n     * @memberof ics23.CompressedBatchEntry\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n\n\n    CompressedBatchEntry.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n      var properties = {};\n\n      if (message.exist != null && message.hasOwnProperty(\"exist\")) {\n        properties.proof = 1;\n        {\n          var error = $root.ics23.CompressedExistenceProof.verify(message.exist);\n          if (error) return \"exist.\" + error;\n        }\n      }\n\n      if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) {\n        if (properties.proof === 1) return \"proof: multiple values\";\n        properties.proof = 1;\n        {\n          var error = $root.ics23.CompressedNonExistenceProof.verify(message.nonexist);\n          if (error) return \"nonexist.\" + error;\n        }\n      }\n\n      return null;\n    };\n    /**\n     * Creates a CompressedBatchEntry message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof ics23.CompressedBatchEntry\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {ics23.CompressedBatchEntry} CompressedBatchEntry\n     */\n\n\n    CompressedBatchEntry.fromObject = function fromObject(object) {\n      if (object instanceof $root.ics23.CompressedBatchEntry) return object;\n      var message = new $root.ics23.CompressedBatchEntry();\n\n      if (object.exist != null) {\n        if (typeof object.exist !== \"object\") throw TypeError(\".ics23.CompressedBatchEntry.exist: object expected\");\n        message.exist = $root.ics23.CompressedExistenceProof.fromObject(object.exist);\n      }\n\n      if (object.nonexist != null) {\n        if (typeof object.nonexist !== \"object\") throw TypeError(\".ics23.CompressedBatchEntry.nonexist: object expected\");\n        message.nonexist = $root.ics23.CompressedNonExistenceProof.fromObject(object.nonexist);\n      }\n\n      return message;\n    };\n    /**\n     * Creates a plain object from a CompressedBatchEntry message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof ics23.CompressedBatchEntry\n     * @static\n     * @param {ics23.CompressedBatchEntry} message CompressedBatchEntry\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    CompressedBatchEntry.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n\n      if (message.exist != null && message.hasOwnProperty(\"exist\")) {\n        object.exist = $root.ics23.CompressedExistenceProof.toObject(message.exist, options);\n        if (options.oneofs) object.proof = \"exist\";\n      }\n\n      if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) {\n        object.nonexist = $root.ics23.CompressedNonExistenceProof.toObject(message.nonexist, options);\n        if (options.oneofs) object.proof = \"nonexist\";\n      }\n\n      return object;\n    };\n    /**\n     * Converts this CompressedBatchEntry to JSON.\n     * @function toJSON\n     * @memberof ics23.CompressedBatchEntry\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    CompressedBatchEntry.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return CompressedBatchEntry;\n  }();\n\n  ics23.CompressedExistenceProof = function () {\n    /**\n     * Properties of a CompressedExistenceProof.\n     * @memberof ics23\n     * @interface ICompressedExistenceProof\n     * @property {Uint8Array|null} [key] CompressedExistenceProof key\n     * @property {Uint8Array|null} [value] CompressedExistenceProof value\n     * @property {ics23.ILeafOp|null} [leaf] CompressedExistenceProof leaf\n     * @property {Array.<number>|null} [path] CompressedExistenceProof path\n     */\n\n    /**\n     * Constructs a new CompressedExistenceProof.\n     * @memberof ics23\n     * @classdesc Represents a CompressedExistenceProof.\n     * @implements ICompressedExistenceProof\n     * @constructor\n     * @param {ics23.ICompressedExistenceProof=} [properties] Properties to set\n     */\n    function CompressedExistenceProof(properties) {\n      this.path = [];\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n    }\n    /**\n     * CompressedExistenceProof key.\n     * @member {Uint8Array} key\n     * @memberof ics23.CompressedExistenceProof\n     * @instance\n     */\n\n\n    CompressedExistenceProof.prototype.key = $util.newBuffer([]);\n    /**\n     * CompressedExistenceProof value.\n     * @member {Uint8Array} value\n     * @memberof ics23.CompressedExistenceProof\n     * @instance\n     */\n\n    CompressedExistenceProof.prototype.value = $util.newBuffer([]);\n    /**\n     * CompressedExistenceProof leaf.\n     * @member {ics23.ILeafOp|null|undefined} leaf\n     * @memberof ics23.CompressedExistenceProof\n     * @instance\n     */\n\n    CompressedExistenceProof.prototype.leaf = null;\n    /**\n     * CompressedExistenceProof path.\n     * @member {Array.<number>} path\n     * @memberof ics23.CompressedExistenceProof\n     * @instance\n     */\n\n    CompressedExistenceProof.prototype.path = $util.emptyArray;\n    /**\n     * Creates a new CompressedExistenceProof instance using the specified properties.\n     * @function create\n     * @memberof ics23.CompressedExistenceProof\n     * @static\n     * @param {ics23.ICompressedExistenceProof=} [properties] Properties to set\n     * @returns {ics23.CompressedExistenceProof} CompressedExistenceProof instance\n     */\n\n    CompressedExistenceProof.create = function create(properties) {\n      return new CompressedExistenceProof(properties);\n    };\n    /**\n     * Encodes the specified CompressedExistenceProof message. Does not implicitly {@link ics23.CompressedExistenceProof.verify|verify} messages.\n     * @function encode\n     * @memberof ics23.CompressedExistenceProof\n     * @static\n     * @param {ics23.ICompressedExistenceProof} message CompressedExistenceProof message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    CompressedExistenceProof.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.key != null && message.hasOwnProperty(\"key\")) writer.uint32(\n      /* id 1, wireType 2 =*/\n      10).bytes(message.key);\n      if (message.value != null && message.hasOwnProperty(\"value\")) writer.uint32(\n      /* id 2, wireType 2 =*/\n      18).bytes(message.value);\n      if (message.leaf != null && message.hasOwnProperty(\"leaf\")) $root.ics23.LeafOp.encode(message.leaf, writer.uint32(\n      /* id 3, wireType 2 =*/\n      26).fork()).ldelim();\n\n      if (message.path != null && message.path.length) {\n        writer.uint32(\n        /* id 4, wireType 2 =*/\n        34).fork();\n\n        for (var i = 0; i < message.path.length; ++i) {\n          writer.int32(message.path[i]);\n        }\n\n        writer.ldelim();\n      }\n\n      return writer;\n    };\n    /**\n     * Encodes the specified CompressedExistenceProof message, length delimited. Does not implicitly {@link ics23.CompressedExistenceProof.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof ics23.CompressedExistenceProof\n     * @static\n     * @param {ics23.ICompressedExistenceProof} message CompressedExistenceProof message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    CompressedExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes a CompressedExistenceProof message from the specified reader or buffer.\n     * @function decode\n     * @memberof ics23.CompressedExistenceProof\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ics23.CompressedExistenceProof} CompressedExistenceProof\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    CompressedExistenceProof.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.ics23.CompressedExistenceProof();\n\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.key = reader.bytes();\n            break;\n\n          case 2:\n            message.value = reader.bytes();\n            break;\n\n          case 3:\n            message.leaf = $root.ics23.LeafOp.decode(reader, reader.uint32());\n            break;\n\n          case 4:\n            if (!(message.path && message.path.length)) message.path = [];\n\n            if ((tag & 7) === 2) {\n              var end2 = reader.uint32() + reader.pos;\n\n              while (reader.pos < end2) {\n                message.path.push(reader.int32());\n              }\n            } else message.path.push(reader.int32());\n\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Decodes a CompressedExistenceProof message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof ics23.CompressedExistenceProof\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {ics23.CompressedExistenceProof} CompressedExistenceProof\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    CompressedExistenceProof.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies a CompressedExistenceProof message.\n     * @function verify\n     * @memberof ics23.CompressedExistenceProof\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n\n\n    CompressedExistenceProof.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n      if (message.key != null && message.hasOwnProperty(\"key\")) if (!(message.key && typeof message.key.length === \"number\" || $util.isString(message.key))) return \"key: buffer expected\";\n      if (message.value != null && message.hasOwnProperty(\"value\")) if (!(message.value && typeof message.value.length === \"number\" || $util.isString(message.value))) return \"value: buffer expected\";\n\n      if (message.leaf != null && message.hasOwnProperty(\"leaf\")) {\n        var error = $root.ics23.LeafOp.verify(message.leaf);\n        if (error) return \"leaf.\" + error;\n      }\n\n      if (message.path != null && message.hasOwnProperty(\"path\")) {\n        if (!Array.isArray(message.path)) return \"path: array expected\";\n\n        for (var i = 0; i < message.path.length; ++i) {\n          if (!$util.isInteger(message.path[i])) return \"path: integer[] expected\";\n        }\n      }\n\n      return null;\n    };\n    /**\n     * Creates a CompressedExistenceProof message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof ics23.CompressedExistenceProof\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {ics23.CompressedExistenceProof} CompressedExistenceProof\n     */\n\n\n    CompressedExistenceProof.fromObject = function fromObject(object) {\n      if (object instanceof $root.ics23.CompressedExistenceProof) return object;\n      var message = new $root.ics23.CompressedExistenceProof();\n      if (object.key != null) if (typeof object.key === \"string\") $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);else if (object.key.length) message.key = object.key;\n      if (object.value != null) if (typeof object.value === \"string\") $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);else if (object.value.length) message.value = object.value;\n\n      if (object.leaf != null) {\n        if (typeof object.leaf !== \"object\") throw TypeError(\".ics23.CompressedExistenceProof.leaf: object expected\");\n        message.leaf = $root.ics23.LeafOp.fromObject(object.leaf);\n      }\n\n      if (object.path) {\n        if (!Array.isArray(object.path)) throw TypeError(\".ics23.CompressedExistenceProof.path: array expected\");\n        message.path = [];\n\n        for (var i = 0; i < object.path.length; ++i) {\n          message.path[i] = object.path[i] | 0;\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Creates a plain object from a CompressedExistenceProof message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof ics23.CompressedExistenceProof\n     * @static\n     * @param {ics23.CompressedExistenceProof} message CompressedExistenceProof\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    CompressedExistenceProof.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n      if (options.arrays || options.defaults) object.path = [];\n\n      if (options.defaults) {\n        if (options.bytes === String) object.key = \"\";else {\n          object.key = [];\n          if (options.bytes !== Array) object.key = $util.newBuffer(object.key);\n        }\n        if (options.bytes === String) object.value = \"\";else {\n          object.value = [];\n          if (options.bytes !== Array) object.value = $util.newBuffer(object.value);\n        }\n        object.leaf = null;\n      }\n\n      if (message.key != null && message.hasOwnProperty(\"key\")) object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;\n      if (message.value != null && message.hasOwnProperty(\"value\")) object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;\n      if (message.leaf != null && message.hasOwnProperty(\"leaf\")) object.leaf = $root.ics23.LeafOp.toObject(message.leaf, options);\n\n      if (message.path && message.path.length) {\n        object.path = [];\n\n        for (var j = 0; j < message.path.length; ++j) {\n          object.path[j] = message.path[j];\n        }\n      }\n\n      return object;\n    };\n    /**\n     * Converts this CompressedExistenceProof to JSON.\n     * @function toJSON\n     * @memberof ics23.CompressedExistenceProof\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    CompressedExistenceProof.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return CompressedExistenceProof;\n  }();\n\n  ics23.CompressedNonExistenceProof = function () {\n    /**\n     * Properties of a CompressedNonExistenceProof.\n     * @memberof ics23\n     * @interface ICompressedNonExistenceProof\n     * @property {Uint8Array|null} [key] CompressedNonExistenceProof key\n     * @property {ics23.ICompressedExistenceProof|null} [left] CompressedNonExistenceProof left\n     * @property {ics23.ICompressedExistenceProof|null} [right] CompressedNonExistenceProof right\n     */\n\n    /**\n     * Constructs a new CompressedNonExistenceProof.\n     * @memberof ics23\n     * @classdesc Represents a CompressedNonExistenceProof.\n     * @implements ICompressedNonExistenceProof\n     * @constructor\n     * @param {ics23.ICompressedNonExistenceProof=} [properties] Properties to set\n     */\n    function CompressedNonExistenceProof(properties) {\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n    }\n    /**\n     * CompressedNonExistenceProof key.\n     * @member {Uint8Array} key\n     * @memberof ics23.CompressedNonExistenceProof\n     * @instance\n     */\n\n\n    CompressedNonExistenceProof.prototype.key = $util.newBuffer([]);\n    /**\n     * CompressedNonExistenceProof left.\n     * @member {ics23.ICompressedExistenceProof|null|undefined} left\n     * @memberof ics23.CompressedNonExistenceProof\n     * @instance\n     */\n\n    CompressedNonExistenceProof.prototype.left = null;\n    /**\n     * CompressedNonExistenceProof right.\n     * @member {ics23.ICompressedExistenceProof|null|undefined} right\n     * @memberof ics23.CompressedNonExistenceProof\n     * @instance\n     */\n\n    CompressedNonExistenceProof.prototype.right = null;\n    /**\n     * Creates a new CompressedNonExistenceProof instance using the specified properties.\n     * @function create\n     * @memberof ics23.CompressedNonExistenceProof\n     * @static\n     * @param {ics23.ICompressedNonExistenceProof=} [properties] Properties to set\n     * @returns {ics23.CompressedNonExistenceProof} CompressedNonExistenceProof instance\n     */\n\n    CompressedNonExistenceProof.create = function create(properties) {\n      return new CompressedNonExistenceProof(properties);\n    };\n    /**\n     * Encodes the specified CompressedNonExistenceProof message. Does not implicitly {@link ics23.CompressedNonExistenceProof.verify|verify} messages.\n     * @function encode\n     * @memberof ics23.CompressedNonExistenceProof\n     * @static\n     * @param {ics23.ICompressedNonExistenceProof} message CompressedNonExistenceProof message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    CompressedNonExistenceProof.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.key != null && message.hasOwnProperty(\"key\")) writer.uint32(\n      /* id 1, wireType 2 =*/\n      10).bytes(message.key);\n      if (message.left != null && message.hasOwnProperty(\"left\")) $root.ics23.CompressedExistenceProof.encode(message.left, writer.uint32(\n      /* id 2, wireType 2 =*/\n      18).fork()).ldelim();\n      if (message.right != null && message.hasOwnProperty(\"right\")) $root.ics23.CompressedExistenceProof.encode(message.right, writer.uint32(\n      /* id 3, wireType 2 =*/\n      26).fork()).ldelim();\n      return writer;\n    };\n    /**\n     * Encodes the specified CompressedNonExistenceProof message, length delimited. Does not implicitly {@link ics23.CompressedNonExistenceProof.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof ics23.CompressedNonExistenceProof\n     * @static\n     * @param {ics23.ICompressedNonExistenceProof} message CompressedNonExistenceProof message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    CompressedNonExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes a CompressedNonExistenceProof message from the specified reader or buffer.\n     * @function decode\n     * @memberof ics23.CompressedNonExistenceProof\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ics23.CompressedNonExistenceProof} CompressedNonExistenceProof\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    CompressedNonExistenceProof.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.ics23.CompressedNonExistenceProof();\n\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.key = reader.bytes();\n            break;\n\n          case 2:\n            message.left = $root.ics23.CompressedExistenceProof.decode(reader, reader.uint32());\n            break;\n\n          case 3:\n            message.right = $root.ics23.CompressedExistenceProof.decode(reader, reader.uint32());\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Decodes a CompressedNonExistenceProof message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof ics23.CompressedNonExistenceProof\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {ics23.CompressedNonExistenceProof} CompressedNonExistenceProof\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    CompressedNonExistenceProof.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies a CompressedNonExistenceProof message.\n     * @function verify\n     * @memberof ics23.CompressedNonExistenceProof\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n\n\n    CompressedNonExistenceProof.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n      if (message.key != null && message.hasOwnProperty(\"key\")) if (!(message.key && typeof message.key.length === \"number\" || $util.isString(message.key))) return \"key: buffer expected\";\n\n      if (message.left != null && message.hasOwnProperty(\"left\")) {\n        var error = $root.ics23.CompressedExistenceProof.verify(message.left);\n        if (error) return \"left.\" + error;\n      }\n\n      if (message.right != null && message.hasOwnProperty(\"right\")) {\n        var error = $root.ics23.CompressedExistenceProof.verify(message.right);\n        if (error) return \"right.\" + error;\n      }\n\n      return null;\n    };\n    /**\n     * Creates a CompressedNonExistenceProof message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof ics23.CompressedNonExistenceProof\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {ics23.CompressedNonExistenceProof} CompressedNonExistenceProof\n     */\n\n\n    CompressedNonExistenceProof.fromObject = function fromObject(object) {\n      if (object instanceof $root.ics23.CompressedNonExistenceProof) return object;\n      var message = new $root.ics23.CompressedNonExistenceProof();\n      if (object.key != null) if (typeof object.key === \"string\") $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);else if (object.key.length) message.key = object.key;\n\n      if (object.left != null) {\n        if (typeof object.left !== \"object\") throw TypeError(\".ics23.CompressedNonExistenceProof.left: object expected\");\n        message.left = $root.ics23.CompressedExistenceProof.fromObject(object.left);\n      }\n\n      if (object.right != null) {\n        if (typeof object.right !== \"object\") throw TypeError(\".ics23.CompressedNonExistenceProof.right: object expected\");\n        message.right = $root.ics23.CompressedExistenceProof.fromObject(object.right);\n      }\n\n      return message;\n    };\n    /**\n     * Creates a plain object from a CompressedNonExistenceProof message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof ics23.CompressedNonExistenceProof\n     * @static\n     * @param {ics23.CompressedNonExistenceProof} message CompressedNonExistenceProof\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    CompressedNonExistenceProof.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n\n      if (options.defaults) {\n        if (options.bytes === String) object.key = \"\";else {\n          object.key = [];\n          if (options.bytes !== Array) object.key = $util.newBuffer(object.key);\n        }\n        object.left = null;\n        object.right = null;\n      }\n\n      if (message.key != null && message.hasOwnProperty(\"key\")) object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;\n      if (message.left != null && message.hasOwnProperty(\"left\")) object.left = $root.ics23.CompressedExistenceProof.toObject(message.left, options);\n      if (message.right != null && message.hasOwnProperty(\"right\")) object.right = $root.ics23.CompressedExistenceProof.toObject(message.right, options);\n      return object;\n    };\n    /**\n     * Converts this CompressedNonExistenceProof to JSON.\n     * @function toJSON\n     * @memberof ics23.CompressedNonExistenceProof\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    CompressedNonExistenceProof.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return CompressedNonExistenceProof;\n  }();\n\n  return ics23;\n}();\n\nmodule.exports = $root;","map":null,"metadata":{},"sourceType":"script"}