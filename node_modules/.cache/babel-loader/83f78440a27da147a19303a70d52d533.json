{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.concat = void 0;\n\nvar xstream_1 = require(\"xstream\");\n/**\n * An implementation of concat that buffers all source stream events\n *\n * Marble diagram:\n *\n * ```text\n * --1--2---3---4-|\n * -a--b-c--d-|\n * --------X---------Y---------Z-\n *           concat\n * --1--2---3---4-abcdXY-------Z-\n * ```\n *\n * This is inspired by RxJS's concat as documented at http://rxmarbles.com/#concat and behaves\n * differently than xstream's concat as discussed in https://github.com/staltz/xstream/issues/170.\n *\n */\n\n\nfunction concat() {\n  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {\n    streams[_key] = arguments[_key];\n  }\n\n  var subscriptions = new Array();\n  var queues = new Array(); // one queue per stream\n\n  var completedStreams = new Set();\n  var activeStreamIndex = 0;\n\n  function reset() {\n    while (subscriptions.length > 0) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      var subscription = subscriptions.shift();\n      subscription.unsubscribe();\n    }\n\n    queues.length = 0;\n    completedStreams.clear();\n    activeStreamIndex = 0;\n  }\n\n  var producer = {\n    start: function start(listener) {\n      streams.forEach(function (_) {\n        return queues.push([]);\n      });\n\n      function emitAllQueuesEvents(streamIndex) {\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n          var element = queues[streamIndex].shift();\n\n          if (element === undefined) {\n            return;\n          }\n\n          listener.next(element);\n        }\n      }\n\n      function isDone() {\n        return activeStreamIndex >= streams.length;\n      }\n\n      if (isDone()) {\n        listener.complete();\n        return;\n      }\n\n      streams.forEach(function (stream, index) {\n        subscriptions.push(stream.subscribe({\n          next: function next(value) {\n            if (index === activeStreamIndex) {\n              listener.next(value);\n            } else {\n              queues[index].push(value);\n            }\n          },\n          complete: function complete() {\n            completedStreams.add(index);\n\n            while (completedStreams.has(activeStreamIndex)) {\n              // this stream completed: emit all and move on\n              emitAllQueuesEvents(activeStreamIndex);\n              activeStreamIndex++;\n            }\n\n            if (isDone()) {\n              listener.complete();\n            } else {\n              // now active stream can have some events queued but did not yet complete\n              emitAllQueuesEvents(activeStreamIndex);\n            }\n          },\n          error: function error(_error) {\n            listener.error(_error);\n            reset();\n          }\n        }));\n      });\n    },\n    stop: function stop() {\n      reset();\n    }\n  };\n  return xstream_1.Stream.create(producer);\n}\n\nexports.concat = concat;","map":null,"metadata":{},"sourceType":"script"}