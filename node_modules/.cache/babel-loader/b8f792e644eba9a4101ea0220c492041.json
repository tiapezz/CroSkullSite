{"ast":null,"code":"import _regeneratorRuntime from \"F:\\\\Mattia\\\\Visual studio\\\\AppCroskull\\\\croskull-nft-marketplace\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _asyncToGenerator from \"F:\\\\Mattia\\\\Visual studio\\\\AppCroskull\\\\croskull-nft-marketplace\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport { ethers } from \"ethers\";\nimport store from \"../store\";\nimport { sendNotification, getSkullsData } from \"../data/dataActions\";\n\nvar fetchRaffleRequest = function fetchRaffleRequest() {\n  return {\n    type: \"FETCH_RAFFLE_REQUEST\"\n  };\n};\n\nvar fetchRaffleSuccess = function fetchRaffleSuccess(payload) {\n  return {\n    type: \"FETCH_RAFFLE_SUCCESS\",\n    payload: payload\n  };\n};\n\nexport var loadRaffleData = function loadRaffleData() {\n  return /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(dispatch) {\n      var _store$getState$block, accountAddress, croRaffle, croSkullsGrave, raffleCount, raffles, i, raffle, winners, isParticipant, playersCount, ipfsHash, hashMetadata, _hashMetadata, type, title, winnersCount, maxParticipants, cost, collectionName, collectionAddress, startTimestamp, description, image, isManager, owner, allowance;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              dispatch(fetchRaffleRequest());\n              _store$getState$block = store.getState().blockchain, accountAddress = _store$getState$block.accountAddress, croRaffle = _store$getState$block.croRaffle, croSkullsGrave = _store$getState$block.croSkullsGrave;\n\n              if (croRaffle) {\n                _context.next = 4;\n                break;\n              }\n\n              return _context.abrupt(\"return\");\n\n            case 4:\n              _context.next = 6;\n              return croRaffle.raffleCounter();\n\n            case 6:\n              raffleCount = _context.sent;\n              raffles = [];\n              _context.next = 10;\n              return raffleCount.toString();\n\n            case 10:\n              raffleCount = _context.sent;\n              console.log(raffleCount);\n\n              if (!raffleCount) {\n                _context.next = 41;\n                break;\n              }\n\n              i = raffleCount - 1;\n\n            case 14:\n              if (!(i > 1)) {\n                _context.next = 41;\n                break;\n              }\n\n              if (!(i <= 1)) {\n                _context.next = 17;\n                break;\n              }\n\n              return _context.abrupt(\"return\");\n\n            case 17:\n              _context.next = 19;\n              return croRaffle.getRaffle(i);\n\n            case 19:\n              raffle = _context.sent;\n              _context.next = 22;\n              return croRaffle.getWinners(i);\n\n            case 22:\n              winners = _context.sent;\n              _context.next = 25;\n              return croRaffle.isParticipant(i);\n\n            case 25:\n              isParticipant = _context.sent;\n              _context.next = 28;\n              return raffle.playersCount.toString();\n\n            case 28:\n              playersCount = _context.sent;\n              ipfsHash = raffle.ipfsHash.replace('ipfs://', 'https://ipfs.infura.io/ipfs/');\n              _context.next = 32;\n              return fetch(ipfsHash);\n\n            case 32:\n              hashMetadata = _context.sent;\n              _context.next = 35;\n              return hashMetadata.json();\n\n            case 35:\n              hashMetadata = _context.sent;\n              _hashMetadata = hashMetadata, type = _hashMetadata.type, title = _hashMetadata.title, winnersCount = _hashMetadata.winnersCount, maxParticipants = _hashMetadata.maxParticipants, cost = _hashMetadata.cost, collectionName = _hashMetadata.collectionName, collectionAddress = _hashMetadata.collectionAddress, startTimestamp = _hashMetadata.startTimestamp, description = _hashMetadata.description, image = _hashMetadata.image;\n              raffles.push({\n                type: type,\n                title: title,\n                id: i,\n                winnersCount: winnersCount,\n                maxParticipants: maxParticipants,\n                cost: cost,\n                image: image,\n                collectionName: collectionName,\n                isParticipant: isParticipant,\n                collectionAddress: collectionAddress,\n                startTimestamp: startTimestamp,\n                endTimestamp: raffle.endTimestamp.toString(),\n                description: description,\n                winners: winners,\n                participants: playersCount\n              });\n\n            case 38:\n              i--;\n              _context.next = 14;\n              break;\n\n            case 41:\n              _context.next = 43;\n              return croRaffle.managers(accountAddress);\n\n            case 43:\n              isManager = _context.sent;\n              _context.next = 46;\n              return croRaffle.owner();\n\n            case 46:\n              owner = _context.sent;\n              if (ethers.utils.getAddress(owner) == ethers.utils.getAddress(accountAddress)) isManager = true;\n              _context.next = 50;\n              return croSkullsGrave.allowance(accountAddress, croRaffle.address);\n\n            case 50:\n              allowance = _context.sent;\n              allowance = allowance.toString();\n              dispatch(fetchRaffleSuccess({\n                raffleCount: raffleCount,\n                init: true,\n                raffles: raffles,\n                allowance: allowance,\n                isManager: isManager\n              }));\n\n            case 53:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n};\n/*\r\nexport const purchaseItem = ( { _listingId, _cost, _skullId } ) => {\r\n    return async (dispatch) => {\r\n        let { ebisusMarketplace } = store.getState().blockchain\r\n        if( ! ebisusMarketplace || ! _listingId) return\r\n        let purchaseTx = ebisusMarketplace.makePurchase(_listingId, {\r\n            value: _cost\r\n        })\r\n        await purchaseTx.then(\r\n            async (tx) => {\r\n                dispatch(sendNotification({\r\n                    title: `Transaction Sent`,\r\n                    message: 'Waiting for confirmation',\r\n                    tx,\r\n                    type: \"info\"\r\n                }))\r\n                await tx.wait(2)\r\n                dispatch(sendNotification({\r\n                    title: `Success`,\r\n                    message: `Item #${_skullId} purchased!`,\r\n                    tx,\r\n                    type: \"success\"\r\n                }))\r\n                dispatch(getSkullsData())\r\n            }\r\n        )\r\n    }\r\n}*/","map":{"version":3,"sources":["F:/Mattia/Visual studio/AppCroskull/croskull-nft-marketplace/src/redux/raffle/raffleActions.js"],"names":["ethers","store","sendNotification","getSkullsData","fetchRaffleRequest","type","fetchRaffleSuccess","payload","loadRaffleData","dispatch","getState","blockchain","accountAddress","croRaffle","croSkullsGrave","raffleCounter","raffleCount","raffles","toString","console","log","i","getRaffle","raffle","getWinners","winners","isParticipant","playersCount","ipfsHash","replace","fetch","hashMetadata","json","title","winnersCount","maxParticipants","cost","collectionName","collectionAddress","startTimestamp","description","image","push","id","endTimestamp","participants","managers","isManager","owner","utils","getAddress","allowance","address","init"],"mappings":"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","sourcesContent":["import { ethers } from \"ethers\";\r\nimport store from \"../store\";\r\nimport { sendNotification, getSkullsData } from \"../data/dataActions\";\r\n\r\nconst fetchRaffleRequest = () => {\r\n  return {\r\n    type: \"FETCH_RAFFLE_REQUEST\",\r\n  };\r\n};\r\n\r\nconst fetchRaffleSuccess = (payload) => {\r\n    return {\r\n      type: \"FETCH_RAFFLE_SUCCESS\",\r\n      payload: payload\r\n    }\r\n}\r\n\r\nexport const loadRaffleData = () => {\r\n    return async (dispatch) => {\r\n        dispatch(fetchRaffleRequest())\r\n        let { accountAddress, croRaffle, croSkullsGrave } = store.getState().blockchain\r\n        if( ! croRaffle ) return\r\n        let raffleCount = await croRaffle.raffleCounter()\r\n        let raffles = []\r\n        \r\n        raffleCount = await raffleCount.toString()\r\n        console.log( raffleCount )\r\n        if( raffleCount ) {\r\n            for( let i = raffleCount-1; i > 1; i--){\r\n                if( i <= 1 ) return\r\n                let raffle = await croRaffle.getRaffle(i)\r\n                let winners = await croRaffle.getWinners(i)\r\n\r\n                let isParticipant = await croRaffle.isParticipant(i)\r\n                let playersCount = await raffle.playersCount.toString()\r\n\r\n                let ipfsHash = raffle.ipfsHash.replace('ipfs://', 'https://ipfs.infura.io/ipfs/')\r\n                let hashMetadata = await fetch( ipfsHash );\r\n                hashMetadata = await hashMetadata.json()\r\n                let { type, title, winnersCount, maxParticipants, cost, collectionName, collectionAddress, startTimestamp, description, image } = hashMetadata;\r\n                raffles.push({\r\n                    type, \r\n                    title,\r\n                    id: i,\r\n                    winnersCount,\r\n                    maxParticipants, \r\n                    cost,\r\n                    image,\r\n                    collectionName,\r\n                    isParticipant,\r\n                    collectionAddress,\r\n                    startTimestamp,\r\n                    endTimestamp: raffle.endTimestamp.toString(),\r\n                    description,\r\n                    winners,\r\n                    participants: playersCount\r\n                })\r\n            }\r\n        }\r\n        let isManager = await croRaffle.managers(accountAddress)\r\n        let owner = await croRaffle.owner()\r\n        if(  ethers.utils.getAddress(owner) == ethers.utils.getAddress( accountAddress ) ) \r\n            isManager = true\r\n\r\n        let allowance = await croSkullsGrave.allowance( accountAddress, croRaffle.address )\r\n        allowance = allowance.toString()\r\n\r\n        dispatch(fetchRaffleSuccess( {\r\n            raffleCount,\r\n            init: true,\r\n            raffles,\r\n            allowance,\r\n            isManager\r\n        } ))\r\n    }\r\n}\r\n/*\r\nexport const purchaseItem = ( { _listingId, _cost, _skullId } ) => {\r\n    return async (dispatch) => {\r\n        let { ebisusMarketplace } = store.getState().blockchain\r\n        if( ! ebisusMarketplace || ! _listingId) return\r\n        let purchaseTx = ebisusMarketplace.makePurchase(_listingId, {\r\n            value: _cost\r\n        })\r\n        await purchaseTx.then(\r\n            async (tx) => {\r\n                dispatch(sendNotification({\r\n                    title: `Transaction Sent`,\r\n                    message: 'Waiting for confirmation',\r\n                    tx,\r\n                    type: \"info\"\r\n                }))\r\n                await tx.wait(2)\r\n                dispatch(sendNotification({\r\n                    title: `Success`,\r\n                    message: `Item #${_skullId} purchased!`,\r\n                    tx,\r\n                    type: \"success\"\r\n                }))\r\n                dispatch(getSkullsData())\r\n            }\r\n        )\r\n    }\r\n}*/"]},"metadata":{},"sourceType":"module"}